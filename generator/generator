#!/usr/bin/env ocaml
(* hey emacs, this is OCaml code: -*- tuareg -*- *)
(* nbd client library in userspace: generator
 * Copyright (C) 2013-2019 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *)

(* This script generates the state machine and language
 * bindings.  After editing this file, run:
 *
 *   generator/generator
 *
 * from the top source directory to regenerate output files.
 *)

#load "str.cma";;
#load "unix.cma";;

open Unix
open Printf

(*----------------------------------------------------------------------*)

(* The state machine.
 *
 * Each state has some associated C code which is called when
 * the state is entered, or when the state is re-entered because
 * of an external event.  That code is not in this file, it's
 * in [generator/states.c].
 *
 * The handle usually contains one connection, but might have more
 * if multi-conn is enabled.  Each connection starts in the CREATED
 * state.  A connection can move between states for one of two
 * reasons: Either the C code associated with the state moves
 * to another state (eg. move to the DEAD state because a system call
 * returns an error).  Or an external event happens which causes
 * the connection to move to a new state.
 *
 * An external event is something like the file descriptor being
 * ready to read or write, or the main program calling a function
 * such as [nbd_aio_connect].  Possible external events, and the
 * next state resulting, are listed in the states table below.
 *
 * An empty string [""] for next state means the same state
 * is re-entered.  The same C code for the state will be called
 * again.
 *
 * If the C code calls SET_NEXT_STATE then the next state is
 * entered immediately.  If the C code does not call SET_NEXT_STATE
 * then the state machine stops until an external event happens.
 * When the external event happens the state machine restarts,
 * either in the same state ([""]) or the new state associated
 * with the external event.
 *)

type external_event =
  | NotifyRead                  (* fd becomes ready to read *)
  | NotifyWrite                 (* fd becomes ready to write *)
  | CmdCreate                   (* [nbd_create] function called *)
  | CmdConnect                  (* [nbd_aio_connect] function called *)
  | CmdIssue                    (* issuing an NBD command *)

type state = {
  comment : string;             (* comment about the state *)

  (* Possible transitions from this state to a next state.  The
   * external events are coded into the state table below.  The
   * internal transitions are parsed out of the C code.
   *)
  external_events : (external_event * string) list;
  mutable internal_transitions : string list;

  (* The C code implementing this state. *)
  mutable code : string;
}

let default_state = { comment = ""; external_events = [];
                      internal_transitions = []; code = "" }

let states = [
  "CREATED", {
    default_state with
    comment = "Connection after being initially created, idle and not connected";
    external_events = [ CmdCreate, "";
                        CmdConnect, "CONNECT" ];
  };

  "CONNECT", {
    default_state with
    comment = "Initial call to connect(2) on the socket";
    external_events = [ NotifyWrite, "CONNECTING" ];
  };

  "CONNECTING", {
    default_state with
    comment = "Connecting to the remote server";
    external_events = [ NotifyWrite, "" ];
  };

  "RECV_MAGIC", {
    default_state with
    comment = "Receive initial magic identification from remote";
    external_events = [ NotifyRead, "" ];
  };

  "CHECK_MAGIC", {
    default_state with
    comment = "Check magic and version sent by remote";
  };

  "RECV_NEWSTYLE_GFLAGS", {
    default_state with
    comment = "Receive newstyle gflags from remote";
    external_events = [ NotifyRead, "" ];
  };

  "CHECK_NEWSTYLE_GFLAGS", {
    default_state with
    comment = "Check global flags sent by remote";
  };

  "SEND_NEWSTYLE_CFLAGS", {
    default_state with
    comment = "Send newstyle client flags to remote";
    external_events = [ NotifyWrite, "" ];
  };

  "TRY_NEWSTYLE_OPT_GO", {
    default_state with
    comment = "Try to send newstyle NBD_OPT_GO to end handshake";
    external_events = [];
  };

  "SEND_NEWSTYLE_OPT_GO", {
    default_state with
    comment = "Send newstyle NBD_OPT_GO to end handshake";
    external_events = [ NotifyWrite, "" ];
  };

  "SEND_NEWSTYLE_OPT_GO_EXPORTNAMELEN", {
    default_state with
    comment = "Send newstyle NBD_OPT_GO export name length";
    external_events = [ NotifyWrite, "" ];
  };

  "SEND_NEWSTYLE_OPT_GO_EXPORT", {
    default_state with
    comment = "Send newstyle NBD_OPT_GO export name";
    external_events = [ NotifyWrite, "" ];
  };

  "SEND_NEWSTYLE_OPT_GO_NRINFOS", {
    default_state with
    comment = "Send newstyle NBD_OPT_GO number of infos";
    external_events = [ NotifyWrite, "" ];
  };

  "RECV_NEWSTYLE_OPT_GO_REPLY", {
    default_state with
    comment = "Receive newstyle NBD_OPT_GO reply";
    external_events = [ NotifyRead, "" ];
  };

  "SKIP_NEWSTYLE_OPT_GO_REPLY_PAYLOAD", {
    default_state with
    comment = "Skip newstyle NBD_OPT_GO reply payload";
    external_events = [ NotifyRead, "" ];
  };

  "CHECK_NEWSTYLE_OPT_GO_REPLY", {
    default_state with
    comment = "Check newstyle NBD_OPT_GO reply";
    external_events = [];
  };

  "READY", {
    default_state with
    comment = "Connection is ready to process NBD commands";
    external_events = [ CmdIssue, "ISSUE_COMMAND";
                        NotifyRead, "PREPARE_FOR_REPLY" ];
  };

  "ISSUE_COMMAND", {
    default_state with
    (* XXX There's a possible deadlock here if a server cannot
     * handle multiple requests pipelined on a single connection.
     * We could try to issue a command and block, but reads might
     * be available.  It should be possible to break this with
     * another state.
     *)
    comment = "Begin issuing a command to the remote server";
    external_events = [];
  };

  "SEND_REQUEST", {
    default_state with
    comment = "Sending a request to the remote server";
    external_events = [ NotifyWrite, "" ];
  };

  "SEND_WRITE_PAYLOAD", {
    default_state with
    comment = "Sending the write payload to the remote server";
    external_events = [ NotifyWrite, "" ];
  };

  "PREPARE_FOR_REPLY", {
    default_state with
    comment = "Prepare to receive a reply from the remote server";
    external_events = [];
  };

  "RECV_REPLY", {
    default_state with
    comment = "Receive a reply from the remote server";
    external_events = [ NotifyRead, "" ];
  };

  "RECV_READ_PAYLOAD", {
    default_state with
    comment = "Receiving the read payload from the remote server";
    external_events = [ NotifyRead, "" ];
  };

  "FINISH_COMMAND", {
    default_state with
    comment = "Finish receiving a command";
    external_events = [];
  };

  "DEAD", {
    default_state with
    comment = "Connection is in an unrecoverable error state, can only be closed";
  };
]

(*----------------------------------------------------------------------*)

(* The API. *)

type call = {
  args : arg list;         (* parameters (except handle) *)
  ret : ret;               (* return value *)
  is_locked : bool;        (* most functions need to take a lock *)
  shortdesc : string;      (* short description *)
  longdesc : string;       (* long description *)
}
and arg =
| BytesIn of string * string (* byte array + size passed in to the function *)
| BytesOut of string * string(* byte array + size specified by caller,
                              written by the function *)
| Int of string            (* small int *)
| Int64 of string          (* 64 bit signed int *)
| Path of string           (* filename or path *)
| SockAddrAndLen of string * string (* struct sockaddr * + socklen_t *)
| String of string         (* string *)
| UInt of string           (* small unsigned int *)
| UInt32 of string         (* 32 bit unsigned int *)
| UInt64 of string         (* 64 bit unsigned int *)
and ret =
| RBool                    (* return a boolean, or error *)
| RConstString             (* return a const string, NULL for error *)
| RErr                     (* return a small int, -1 = error *)
| RFd                      (* return a file descriptor, or error *)
| RInt64                   (* 64 bit int, -1 = error *)

let default_call = { args = []; ret = RErr; is_locked = true;
                     shortdesc = ""; longdesc = "" }

(* Calls on [nbd_handle *nbd] *)
let handle_calls = [
  "set_multi_conn", {
    default_call with
    args = [ UInt "multi_conn" ]; ret = RErr;
    shortdesc = "enable or disable multi-conn and set nr connections";
    longdesc = "\
NBD can make multiple connections, if the server supports it.
The C<multi_conn> parameter controls whether this feature is
enabled (if E<gt> 1) or disabled (if C<1>).  The parameter
passed must not be C<0>.  Usually small powers of 2 (eg. 2, 4, 8)
will provide increments in performance.  Some servers do not
support this feature and will return an error on connection.";
  };

  "connect_unix", {
    default_call with
    args = [ Path "sockpath" ]; ret = RErr;
    shortdesc = "connect to NBD server over a Unix domain socket";
    longdesc = "\
Connect (synchronously) over the named Unix domain socket (C<sockpath>)
to an NBD server running on the same machine.  This call returns
when the connection has been made.  If multi-conn is enabled, this
begins connecting all of the connections, and returns as soon as
any one of them is connected.";
  };

  "pread", {
    default_call with
    args = [ BytesOut ("buf", "count"); UInt64 "offset" ];
    ret = RErr;
    shortdesc = "read from the NBD server";
    longdesc = "\
Issue a read command to the NBD server for the range starting
at C<offset> and ending at C<offset> + C<count> - 1.  NBD
can only read all or nothing using this call.  The call
returns when the data has been read fully into C<buf> or there is an
error.

If multi-conn is enabled, the command is issued on the next
ready connection, picked in a round-robin manner.";
  };

  "pwrite", {
    default_call with
    args = [ BytesIn ("buf", "count"); UInt64 "offset"; UInt32 "flags" ];
    ret = RErr;
    shortdesc = "write to the NBD server";
    longdesc = "\
Issue a write command to the NBD server, writing the data in
C<buf> to the range starting at C<offset> and ending at
C<offset> + C<count> - 1.  NBD can only write all or nothing
using this call.  The call returns when the data has been written
fully and acknowledged by the server, or there is an error.

The C<flags> parameter may be C<0> for no flags, or may contain
C<LIBNBD_CMD_FLAG_FUA> meaning that the server should not
return until the data has been committed to permanent storage
(if that is supported - some servers cannot do this).

If multi-conn is enabled, the command is issued on the next
ready connection, picked in a round-robin manner.";
  };

  "poll", {
    default_call with
    args = [ Int "timeout" ];
    ret = RErr;
    shortdesc = "poll the handle once";
    longdesc = "\
This is a simple implementation of L<poll(2)> which is used
internally by synchronous API calls.  It is mainly useful as
an example of how you might integrate libnbd with your own
main loop, rather than being intended as something you would use.";
  };




]

(* Calls on [nbd_connection *conn] *)
let connection_calls = [
  "aio_connect", {
    default_call with
    args = [ SockAddrAndLen ("addr", "addrlen") ];
    ret = RErr;
    shortdesc = "connect to the NBD server";
    longdesc = "\
Begin connecting to the NBD server.  You can check if the
connection has connected to the server and completed the NBD
handshake by calling C<nbd_aio_is_ready> on the connection.";
  };

  "aio_pread", {
    default_call with
    args = [ BytesOut ("buf", "count"); UInt64 "offset" ];
    ret = RInt64;
    shortdesc = "read from the NBD server";
    longdesc = "\
Issue a read command to the NBD server.  This returns the
unique 64 bit handle for this command.  To check if the command
completed, call C<nbd_aio_command_completed>.  Note that
you must ensure C<buf> is valid until the command has
completed.";
  };

  "aio_pwrite", {
    default_call with
    args = [ BytesIn ("buf", "count"); UInt64 "offset"; UInt32 "flags" ];
    ret = RInt64;
    shortdesc = "write to the NBD server";
    longdesc = "\
Issue a write command to the NBD server.  This returns the
unique 64 bit handle for this command.  To check if the command
completed, call C<nbd_aio_command_completed>.  Note that
you must ensure C<buf> is valid until the command has
completed.";
  };

  "aio_get_fd", {
    default_call with
    args = [];
    ret = RFd;
    shortdesc = "return file descriptor associated with this connection";
    longdesc = "\
Return the underlying file descriptor associated with this
connection.  You can use this to check if the file descriptor
is ready for reading or writing and call C<nbd_aio_notify_read>
or C<nbd_aio_notify_write>.  See also C<nbd_aio_get_direction>.
Do not do anything else with the file descriptor.";
  };

  "aio_get_direction", {
    default_call with
    args = [];
    ret = RErr;
    shortdesc = "return the read or write direction";
    longdesc = "\
Return the current direction of this connection, which means
whether we are next expecting to read data from the server, write
data to the server, or both.  It returns

=over 4

=item C<LIBNBD_AIO_DIRECTION_READ> = 1

We are expected next to read from the server.  If using L<poll(2)>
you would set C<events = POLLIN>.  If C<revents> returns C<POLLIN>
you would then call C<nbd_aio_notify_read>.

=item C<LIBNBD_AIO_DIRECTION_WRITE> = 2

We are expected next to write to the server.  If using L<poll(2)>
you would set C<events = POLLOUT>.  If C<revents> returns C<POLLOUT>
you would then call C<nbd_aio_notify_write>.

=item C<LIBNBD_AIO_DIRECTION_BOTH> = 3

We are expected next to either read or write to the server.
If using L<poll(2)> you would set C<events = POLLIN|POLLOUT>.
If one of C<POLLIN> or C<POLLOUT> is returned, then see above.
However note that you shouldn't call C<nbd_aio_notify_read>
and C<nbd_aio_notify_write> because calling the first one will
change the state of the connection, possibly invalidating the second
notification.

=back";
  };

  "aio_notify_read", {
    default_call with
    args = [];
    ret = RErr;
    shortdesc = "notify that the connection is readable";
    longdesc = "\
Send notification to the state machine that the connection
is readable.  Typically this is called after your main loop
has detected that the file descriptor associated with this
connection is readable.";
  };

  "aio_notify_write", {
    default_call with
    args = [];
    ret = RErr;
    shortdesc = "notify that the connection is writable";
    longdesc = "\
Send notification to the state machine that the connection
is writable.  Typically this is called after your main loop
has detected that the file descriptor associated with this
connection is writable.";
  };

  "aio_is_ready", {
    default_call with
    args = [];
    ret = RBool;
    shortdesc = "check if the connection is in the ready state";
    longdesc = "\
Return true if this connection is connected to the NBD server,
the handshake has completed, and the connection is idle or
waiting for a reply.  In this state the handle is ready to
issue commands.";
  };

  "aio_is_dead", {
    default_call with
    args = [];
    ret = RBool;
    shortdesc = "check if the connection is dead";
    longdesc = "\
Return true if the connection has encountered a fatal
error and is dead.  In this state the connection (or whole handle)
may only be closed.  There is no way to recover a handle from
the dead state.";
  };

  "aio_command_completed", {
    default_call with
    args = [Int64 "handle"];
    ret = RBool;
    shortdesc = "check if the command completed";
    longdesc = "\
Return true if the command completed.  If this function returns
true then the command was successful and it has been retired.
Return false if the command is still in flight.  This can also
fail with an error in case the command failed (in this case
the command is also retired).

The C<handle> parameter is the unique 64 bit handle for the command,
as returned by a call such as C<nbd_aio_pread>.";
  };

  "connection_state", {
    default_call with
    args = [];
    ret = RConstString;
    shortdesc = "return a descriptive string for the state of the connection";
    longdesc = "\
Returns a descriptive string for the state of the connection.  This
can be used for debugging or troubleshooting, but you should not
rely on the state of connections since it may change in future
versions.";
  };





]

(*----------------------------------------------------------------------*)

(* Helper functions. *)

let failwithf fs = ksprintf failwith fs

let rec filter_map f = function
  | [] -> []
  | x :: xs ->
      match f x with
      | Some y -> y :: filter_map f xs
      | None -> filter_map f xs

let chan = ref Pervasives.stdout
let pr fs = ksprintf (fun str -> output_string !chan str) fs

type comment_style =
  | CStyle | CPlusPlusStyle | HashStyle | OCamlStyle | HaskellStyle
  | PODCommentStyle

let generate_header ?(extra_sources = []) comment_style =
  let inputs = "generator/generator" :: extra_sources in
  let c = match comment_style with
    | CStyle ->         pr "/* "; " *"
    | CPlusPlusStyle -> pr "// "; "//"
    | HashStyle ->      pr "# ";  "#"
    | OCamlStyle ->     pr "(* "; " *"
    | HaskellStyle ->   pr "{- "; "  "
    | PODCommentStyle -> pr "=begin comment\n\n "; "" in
  pr "NBD client library in userspace\n";
  pr "%s WARNING: THIS FILE IS GENERATED FROM\n" c;
  pr "%s %s\n" c (String.concat " " inputs);
  pr "%s ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.\n" c;
  pr "%s\n" c;
  pr "%s Copyright (C) 2013-2019 Red Hat Inc.\n" c;
  pr "%s\n" c;
  pr "%s This library is free software; you can redistribute it and/or\n" c;
  pr "%s modify it under the terms of the GNU Lesser General Public\n" c;
  pr "%s License as published by the Free Software Foundation; either\n" c;
  pr "%s version 2 of the License, or (at your option) any later version.\n" c;
  pr "%s\n" c;
  pr "%s This library is distributed in the hope that it will be useful,\n" c;
  pr "%s but WITHOUT ANY WARRANTY; without even the implied warranty of\n" c;
  pr "%s MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n" c;
  pr "%s Lesser General Public License for more details.\n" c;
  pr "%s\n" c;
  pr "%s You should have received a copy of the GNU Lesser General Public\n" c;
  pr "%s License along with this library; if not, write to the Free Software\n" c;
  pr "%s Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n" c;
  (match comment_style with
   | CStyle -> pr " */\n"
   | CPlusPlusStyle
   | HashStyle -> ()
   | OCamlStyle -> pr " *)\n"
   | HaskellStyle -> pr "-}\n"
   | PODCommentStyle -> pr "\n=end comment\n"
  );
  pr "\n"

let files_equal n1 n2 =
  let cmd = sprintf "cmp -s %s %s" (Filename.quote n1) (Filename.quote n2) in
  match Sys.command cmd with
  | 0 -> true
  | 1 -> false
  | i -> failwithf "%s: failed with error code %d" cmd i

let output_to filename k =
  let filename_new = filename ^ ".new" in
  chan := open_out filename_new;
  k ();
  close_out !chan;
  chan := Pervasives.stdout;

  (* Is the new file different from the current file? *)
  if Sys.file_exists filename && files_equal filename filename_new then
    unlink filename_new                 (* same, so skip it *)
  else (
    (* different, overwrite old one *)
    (try chmod filename 0o644 with Unix_error _ -> ());
    rename filename_new filename;
    chmod filename 0o444;
    printf "written %s\n%!" filename;
  )

(*----------------------------------------------------------------------*)

(* Implement state machine. *)

let string_of_external_event = function
  | NotifyRead -> "NotifyRead"
  | NotifyWrite -> "NotifyWrite"
  | CmdCreate -> "CmdCreate"
  | CmdConnect -> "CmdConnect"
  | CmdIssue -> "CmdIssue"

let c_string_of_external_event = function
  | NotifyRead -> "notify_read"
  | NotifyWrite -> "notify_write"
  | CmdCreate -> "cmd_create"
  | CmdConnect -> "cmd_connect"
  | CmdIssue -> "cmd_issue"

let state_machine_prologue =
  let chan = open_in "generator/states.c" in
  let lines = ref [] in
  (try while true do lines := input_line chan :: !lines done
   with End_of_file -> ());
  close_in chan;
  let lines = !lines in

  (* The last line in the file (which is the first element in lines
   * before we reverse the list) must have a particular form, check
   * and remove.
   *)
  if List.length lines = 0 || List.hd lines <> "} /* END STATE MACHINE */" then
    failwith "generator/states.c: unexpected file ending";
  let lines = List.tl lines in
  let lines = List.rev lines in

  (* Find the start of the state machine and split the list into
   * the prologue and the list of state code fragments.
   *)
  let prologue, statecodes =
    let rec loop acc = function
      | [] -> failwith "generator/states.c: could not find state machine"
      | "/* STATE MACHINE */ {" :: lines -> acc, lines
      | line :: lines -> loop (acc ^ "\n" ^ line) lines
    in
    let prologue, lines = loop "" lines in

    let statecodes = ref [] in
    let curr_state = ref None in
    let rex = Str.regexp "^ \\([A-Z0-9][A-Z0-9_]*\\):$" in
    List.iter (
      fun line ->
        if Str.string_match rex line 0 then ( (* new case *)
          (match !curr_state with
           | None -> ()
           | Some state -> statecodes := state :: !statecodes);
          curr_state := Some (Str.matched_group 1 line, "");
        )
        else (
          (match !curr_state with
           | None -> failwith "generator/states.c: missing label"
           | Some (name, code) ->
              curr_state := Some (name, code ^ "\n" ^ line)
          )
        );
    ) lines;
    (match !curr_state with
     | None -> ()
     | Some state -> statecodes := state :: !statecodes);
    let statecodes = List.rev !statecodes in

    prologue, statecodes in

  (* Check there are no code fragments which don't correspond
   * to a known state in the states table.
   *)
  List.iter (
    fun (name, _) ->
      if not (List.mem_assoc name states) then
        failwithf "generator/states.c: unknown state: %s" name
  ) statecodes;

  (* Parse the state code fragments to get internal state
   * transitions, marked by "%STATE".
   *)
  let rex = Str.regexp "%\\([A-Z0-9][A-Z0-9_]*\\)" in
  List.iter (
    fun (name, code) ->
      let code = Str.full_split rex code in
      let code =
        List.map (
          function
          | Str.Delim name ->
             Str.Delim (String.sub name 1 (String.length name - 1))
          | (Str.Text _) as c -> c
      ) code in
      (* Check all the next states exist. *)
      List.iter (
        function
        | Str.Delim name ->
           if not (List.mem_assoc name states) then
             failwithf "generator/states.c: unknown next state: %%%s" name
        | Str.Text _ -> ()
      ) code;

      (* Create the list of internal transitions. *)
      let state = List.assoc name states in
      state.internal_transitions <- (
        filter_map (function Str.Delim name -> Some name | Str.Text _ -> None)
                   code
      );

      (* Create the final C code fragment. *)
      state.code <- (
        String.concat "" (
          List.map (
            function
            | Str.Delim name -> "STATE_" ^ name
            | Str.Text text -> text
          ) code
        )
      );
  ) statecodes;

  prologue

(* Write the state machine code. *)
let generate_lib_states_h () =
  generate_header ~extra_sources:["generator/states.c"] CStyle;
  pr "enum state {\n";
  List.iter (
    fun (name, { comment }) ->
      pr "  /* %s */\n" comment;
      pr "  STATE_%s,\n" name;
      pr "\n";
  ) states;
  pr "};\n"

let generate_lib_states_c () =
  generate_header ~extra_sources:["generator/states.c"] CStyle;

  pr "%s\n" state_machine_prologue;
  pr "\n";
  pr "#define SET_NEXT_STATE(s) (*blocked = false, *next_state = (s))\n";
  pr "\n";

  (* The state machine C code fragments. *)
  List.iter (
    fun (name, { comment; code }) ->
      pr "/* %s */\n" comment;
      pr "static int\n";
      pr "_enter_STATE_%s (struct nbd_handle *h,\n" name;
      pr "             struct nbd_connection *conn,\n";
      pr "             enum state *next_state,\n";
      pr "             bool *blocked)\n";
      pr "{\n";
      if code <> "" then
        pr "%s\n" code
      else
        pr "  return 0;\n";
      pr "}\n";
      pr "\n";
      pr "static int\n";
      pr "enter_STATE_%s (struct nbd_handle *h, struct nbd_connection *conn,\n"
         name;
      pr "            bool *blocked)\n";
      pr "{\n";
      pr "  int r;\n";
      pr "  enum state next_state = STATE_%s;\n" name;
      pr "\n";
      pr "  r = _enter_STATE_%s (h, conn, &next_state, blocked);\n" name;
      pr "  if (conn->state != next_state) {\n";
      pr "    debug (\"conn %%p: transition: %%s -> %%s\", conn, \"%s\",\n"
         name;
      pr "           nbd_internal_state_short_string (next_state));\n";
      pr "    conn->state = next_state;\n";
      pr "  }\n";
      pr "  return r;\n";
      pr "}\n";
      pr "\n";
  ) states;

  pr "/* Run the state machine based on an external event until it would block. */\n";
  pr "int\n";
  pr "nbd_internal_run (struct nbd_handle *h, struct nbd_connection *conn,\n";
  pr "                  enum external_event ev)\n";
  pr "{\n";
  pr "  int r;\n";
  pr "  bool blocked;\n";
  pr "\n";
  pr "  /* Validate and handle the external event. */\n";
  pr "  switch (conn->state)\n";
  pr "  {\n";
  List.iter (
    fun (name, { external_events }) ->
      pr "  case STATE_%s:\n" name;
      if external_events <> [] then (
        pr "    switch (ev)\n";
        pr "    {\n";
        List.iter (
          fun (e, next_state) ->
            pr "    case %s:\n" (c_string_of_external_event e);
            if next_state <> "" then (
              pr "      conn->state = STATE_%s;\n" next_state;
              pr "      debug (\"conn %%p: event %%s: %%s -> %%s\",\n";
              pr "             conn, \"%s\", \"%s\", \"%s\");\n"
                 (string_of_external_event e) name next_state;
            );
            pr "      goto ok;\n";
        ) external_events;
        pr "    default: ; /* nothing, silence GCC warning */\n";
        pr "    }\n";
      );
      pr "    break;\n";
  ) states;
  pr "  }\n";
  pr "\n";
  pr "  set_error (0, \"external event %%d is invalid in state %%s\",\n";
  pr "             ev, nbd_internal_state_short_string (conn->state));\n";
  pr "  return -1;\n";
  pr "\n";
  pr " ok:\n";
  pr "  do {\n";
  pr "    blocked = true;\n";
  pr "\n";
  pr "    /* Run a single step. */\n";
  pr "    switch (conn->state)\n";
  pr "    {\n";
  List.iter (
    fun (name, _) ->
      pr "    case STATE_%s:\n" name;
      pr "      r = enter_STATE_%s (h, conn, &blocked);\n" name;
      pr "      break;\n"
  ) states;
  pr "    }\n";
  pr "\n";
  pr "    if (r == -1) return -1;\n";
  pr "  } while (!blocked);\n";
  pr "  return 0;\n";
  pr "}\n";
  pr "\n";

  pr "/* Returns whether in the current state read or write would be valid. */\n";
  pr "int\n";
  pr "nbd_unlocked_aio_get_direction (struct nbd_connection *conn)\n";
  pr "{\n";
  pr "  int r = 0;\n";
  pr "\n";
  pr "  switch (conn->state)\n";
  pr "  {\n";
  List.iter (
    fun (name, { external_events }) ->
      pr "  case STATE_%s:\n" name;
      List.iter (
        fun (e, _) ->
          match e with
          | NotifyRead ->  pr "    r |= LIBNBD_AIO_DIRECTION_READ;\n"
          | NotifyWrite -> pr "    r |= LIBNBD_AIO_DIRECTION_WRITE;\n"
          | CmdCreate | CmdConnect | CmdIssue -> ()
      ) external_events;
      pr "    break;\n";
  ) states;
  pr "  }\n";
  pr "\n";
  pr "  return r;\n";
  pr "}\n";
  pr "\n";

  pr "/* Other functions associated with the state machine. */\n";
  pr "const char *\n";
  pr "nbd_internal_state_short_string (enum state state)\n";
  pr "{\n";
  pr "  switch (state)\n";
  pr "  {\n";
  List.iter (
    fun (name, { comment }) ->
      pr "  case STATE_%s:\n" name;
      pr "    return \"%s\";\n" name
  ) states;
  pr "  }\n";
  pr "\n";
  pr "  /* This function is only used for debug messages, and\n";
  pr "   * this should never happen.\n";
  pr "   */\n";
  pr "  return \"UNKNOWN!\";\n";
  pr "}\n";
  pr "\n";

  pr "const char *\n";
  pr "nbd_unlocked_connection_state (struct nbd_connection *conn)\n";
  pr "{\n";
  pr "  switch (conn->state)\n";
  pr "  {\n";
  List.iter (
    fun (name, { comment }) ->
      pr "  case STATE_%s:\n" name;
      pr "    return \"%s\" \": \"\n" name;
      pr "           \"%s\";\n" comment;
      pr "\n";
  ) states;
  pr "  }\n";
  pr "\n";
  pr "  return NULL;\n";
  pr "}\n"

(*----------------------------------------------------------------------*)

(* Generate C API. *)

let generate_lib_libnbd_syms () =
  generate_header HashStyle;

  pr "{\n";
  pr "  global:\n";
  pr "    nbd_create;\n";
  pr "    nbd_close;\n";
  pr "    nbd_get_connection;\n";
  pr "    nbd_connection_close;\n";
  List.iter (fun (name, _) -> pr "    nbd_%s;\n" name) handle_calls;
  List.iter (fun (name, _) -> pr "    nbd_%s;\n" name) connection_calls;
  pr "\n";
  pr "  # Everything else is hidden.\n";
  pr "  local: *;\n";
  pr "};\n"

let name_of_arg = function
| BytesIn (n, len) -> [n; len]
| BytesOut (n, len) -> [n; len]
| Int n -> [n]
| Int64 n -> [n]
| Path n -> [n]
| SockAddrAndLen (n, len) -> [n; len]
| String n -> [n]
| UInt n -> [n]
| UInt32 n -> [n]
| UInt64 n -> [n]

let print_extern name htype args ret =
  pr "extern ";
  (match ret with
   | RBool
   | RErr
   | RFd -> pr "int "
   | RConstString -> pr "const char *"
   | RInt64 -> pr "int64_t "
  );
  pr "nbd_%s (struct nbd_%s *" name htype;
  List.iter (
    function
    | BytesIn (n, len) -> pr ", const void *%s, size_t %s" n len
    | BytesOut (n, len) -> pr ", void *%s, size_t %s" n len
    | Int n -> pr ", int %s" n
    | Int64 n -> pr ", int64_t %s" n
    | Path n
    | String n -> pr ", const char *%s" n
    | SockAddrAndLen (n, len) ->
       pr ", const struct sockaddr *%s, socklen_t %s" n len
    | UInt n -> pr ", unsigned %s" n
    | UInt32 n -> pr ", uint32_t %s" n
    | UInt64 n -> pr ", uint64_t %s" n
  ) args;
  pr ");\n"

let generate_include_libnbd_h () =
  generate_header CStyle;

  pr "#ifndef LIBNBD_H\n";
  pr "#define LIBNBD_H\n";
  pr "\n";
  pr "#include <stdint.h>\n";
  pr "#include <sys/socket.h>\n";
  pr "\n";
  pr "struct nbd_handle;\n";
  pr "struct nbd_connection;\n";
  pr "\n";
  pr "#define LIBNBD_AIO_DIRECTION_READ  1\n";
  pr "#define LIBNBD_AIO_DIRECTION_WRITE 2\n";
  pr "#define LIBNBD_AIO_DIRECTION_BOTH  3\n";
  pr "\n";
  pr "#define LIBNBD_CMD_FLAG_FUA        (1<<0)\n";
  pr "\n";
  pr "extern struct nbd_handle *nbd_create (void);\n";
  pr "extern void nbd_close (struct nbd_handle *h);\n";
  pr "\n";
  List.iter (
    fun (name, { args; ret }) -> print_extern name "handle" args ret
  ) handle_calls;
  pr "\n";
  pr "extern struct nbd_connection *nbd_get_connection (struct nbd_handle *h,\n";
  pr "                                                  unsigned i);\n";
  pr "extern int nbd_connection_close (struct nbd_connection *conn);\n";
  pr "\n";
  List.iter (
    fun (name, { args; ret }) -> print_extern name "connection" args ret
  ) connection_calls;
  pr "\n";
  pr "#endif /* LIBNBD_H */\n"

let generate_lib_unlocked_h () =
  generate_header CStyle;

  pr "#ifndef LIBNBD_UNLOCKED_H\n";
  pr "#define LIBNBD_UNLOCKED_H\n";
  pr "\n";
  List.iter (
    fun (name, { args; ret }) ->
      print_extern ("unlocked_" ^ name) "handle" args ret
  ) handle_calls;
  pr "\n";
  List.iter (
    fun (name, { args; ret }) ->
      print_extern ("unlocked_" ^ name) "connection" args ret
  ) connection_calls;
  pr "\n";
  pr "#endif /* LIBNBD_UNLOCKED_H */\n"

(* Generate wrappers around each API call which are a place to
 * grab the thread mutex (lock) and do logging.
 *)
let generate_lib_api_c () =
  let print_wrapper name htype hname lock args ret =
    (match ret with
     | RBool
     | RErr
     | RFd -> pr "int\n"
     | RConstString -> pr "const char *\n"
     | RInt64 -> pr "int64_t\n"
    );
    pr "nbd_%s (struct nbd_%s *%s" name htype hname;
    List.iter (
      function
      | BytesIn (n, len) -> pr ", const void *%s, size_t %s" n len
      | BytesOut (n, len) -> pr ", void *%s, size_t %s" n len
      | Int n -> pr ", int %s" n
      | Int64 n -> pr ", int64_t %s" n
      | Path n
      | String n -> pr ", const char *%s" n
      | SockAddrAndLen (n, len) ->
         pr ", const struct sockaddr *%s, socklen_t %s" n len
      | UInt n -> pr ", unsigned %s" n
      | UInt32 n -> pr ", uint32_t %s" n
      | UInt64 n -> pr ", uint64_t %s" n
    ) args;
    pr ")\n";
    pr "{\n";
    (match ret with
     | RBool
     | RErr
     | RFd -> pr "  int ret;\n"
     | RConstString -> pr "  const char *ret;\n"
     | RInt64 -> pr "  int64_t ret;\n"
    );
    pr "\n";
    pr "  pthread_mutex_lock (&%s);\n" lock;
    pr "  ret = nbd_unlocked_%s (%s" name hname;
    let argnames = List.flatten (List.map name_of_arg args) in
    List.iter (pr ", %s") argnames;
    pr ");\n";
    pr "  pthread_mutex_unlock (&%s);\n" lock;
    pr "  return ret;\n";
    pr "}\n";
    pr "\n";
  in

  generate_header CStyle;

  pr "#include <config.h>\n";
  pr "\n";
  pr "#include <stdio.h>\n";
  pr "#include <stdlib.h>\n";
  pr "\n";
  pr "#include <pthread.h>\n";
  pr "\n";
  pr "#include \"libnbd.h\"\n";
  pr "#include \"internal.h\"\n";
  pr "\n";
  List.iter (
    fun (name, { args; ret }) ->
      print_wrapper name "handle" "h" "h->lock" args ret
  ) handle_calls;
  pr "\n";
  List.iter (
    fun (name, { args; ret }) ->
      print_wrapper name "connection" "conn" "conn->h->lock" args ret
  ) connection_calls

(*----------------------------------------------------------------------*)

(* Write the output files. *)
let () =
  output_to "lib/states.h" generate_lib_states_h;
  output_to "lib/states.c" generate_lib_states_c;
  output_to "lib/libnbd.syms" generate_lib_libnbd_syms;
  output_to "include/libnbd.h" generate_include_libnbd_h;
  output_to "lib/unlocked.h" generate_lib_unlocked_h;
  output_to "lib/api.c" generate_lib_api_c
