#!/usr/bin/env ocaml
(* hey emacs, this is OCaml code: -*- tuareg -*- *)
(* nbd client library in userspace: generator
 * Copyright (C) 2013-2019 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *)

(* This script generates the state machine and language
 * bindings.  After editing this file, run:
 *
 *   generator/generator
 *
 * from the top source directory to regenerate output files.
 *)

#load "str.cma";;
#load "unix.cma";;

open Unix
open Printf

(*----------------------------------------------------------------------*)

(* The state machine.
 *
 * Each state has some associated C code which is called when
 * the state is entered, or when the state is re-entered because
 * of an external event.  That code is not in this file, it's
 * in [generator/states*.c].
 *
 * The state machine applies to connections, not handles.  A
 * handle can contain more than one connection if using multi-conn.
 *
 * Each connection starts in the top level START state.
 *
 * When you enter a state, the associated C code for that state
 * runs.  If the C code calls SET_NEXT_STATE then the connection
 * enters the next state without blocking.  If the C code does _not_
 * call SET_NEXT_STATE before returning then the state machine
 * blocks and will not be re-entered until an external event
 * happens (see below).
 *
 * There are various end states such as CLOSED and DEAD.  These
 * are not special, it's just that they have no way to move to
 * another state.
 *
 * An external event is something like the file descriptor being
 * ready to read or write, or the main program calling a function
 * such as [nbd_aio_connect].  Possible external events, and the
 * next state resulting, are listed in the states table below.
 *
 * An empty string [""] for an external event’s next state means
 * the same state is re-entered.  The same C code for the state
 * will be run again.
 *
 * States can be grouped hierarchically.  States can be referred
 * to by an absolute path from the top level, such as ".DEAD",
 * or by a relative path from the current level, such as "CONNECT"
 * (another state at the same level), "REPLY.START" (a state in
 * a sub-group), or "^FINISH_COMMAND" (a state in the level above
 * the current one).  When entering a group you must enter at the
 * START state.  When leaving a group and going to a higher level
 * in the state tree there is no restriction on the next state.
 *)

type external_event =
  | NotifyRead                  (* fd becomes ready to read *)
  | NotifyWrite                 (* fd becomes ready to write *)
  | CmdCreate                   (* [nbd_create] function called *)
  | CmdConnectSockAddr          (* [nbd_aio_connect] function called *)
  | CmdConnectTCP               (* [nbd_aio_connect_tcp] *)
  | CmdConnectCommand           (* [nbd_aio_connect_command] *)
  | CmdIssue                    (* issuing an NBD command *)

type location = string * int    (* source location: file, line number *)
let noloc = ("", 0)

type state = {
  (* The state name (without prefix).  If this has the special name
   * "START" then it is the start state of the current group.  Each
   * group can only have one start state.
   *)
  name : string;

  comment : string;             (* comment about the state *)

  (* Possible transitions from this state to a next state.  The
   * external events are coded into the state table below.  The
   * internal transitions are parsed out of the C code.
   *)
  external_events : (external_event * string) list;

  (* After flattening the state machine, the generator fills
   * in the extra fields in [state.parsed].
   *)
  mutable parsed : parsed_state;
}

and parsed_state = {
  (* The hierarchy group prefix.  For states in the top level
   * state machine this is an empty list.  For states in the
   * next level down this is a single element, and so on.
   *)
  prefix : string list;

  (* Hierarchical state name, like "NEWSTYLE.OPT_STARTTLS.CHECK_REPLY"
   * for use in debug messages etc.
   *)
  display_name : string;

  (* The STATE_* enum used in the generated C code. *)
  state_enum : string;

  (* The C code implementing this state. *)
  loc : location;
  code : string;

  (* Internal transitions, parsed out of the C code. *)
  internal_transitions : state list;

  (* External events after resolving them to the destination states. *)
  events : (external_event * state) list;
}

let default_state = { name = ""; comment = ""; external_events = [];
                      parsed = { prefix = []; display_name = "";
                                 state_enum = ""; loc = noloc; code = "";
                                 internal_transitions = []; events = [] } }

(* The type of the hierarchical state machine. *)
type state_machine = state_group list
and state_group =
  | Group of string * state_machine (* string is name/prefix of the group *)
  | State of state

(* Top level state machine. *)
let rec state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Connection after being initially created";
    external_events = [ CmdCreate, "";
                        CmdConnectSockAddr, "CONNECT.START";
                        CmdConnectTCP, "CONNECT_TCP.START";
                        CmdConnectCommand, "CONNECT_COMMAND.START" ];
  };

  Group ("CONNECT", connect_state_machine);
  Group ("CONNECT_TCP", connect_tcp_state_machine);
  Group ("CONNECT_COMMAND", connect_command_state_machine);

  Group ("MAGIC", magic_state_machine);
  Group ("OLDSTYLE", oldstyle_state_machine);
  Group ("NEWSTYLE", newstyle_state_machine);

  State {
    default_state with
    name = "READY";
    comment = "Connection is ready to process NBD commands";
    external_events = [ CmdIssue, "ISSUE_COMMAND.START";
                        NotifyRead, "REPLY.START" ];
  };

  Group ("ISSUE_COMMAND", issue_command_state_machine);
  Group ("REPLY", reply_state_machine);

  State {
    default_state with
    name = "DEAD";
    comment = "Connection is in an unrecoverable error state, can only be closed";
  };

  State {
    default_state with
    name = "CLOSED";
    comment = "Connection is closed";
  };
]

(* State machine implementing [nbd_aio_connect] and Unix domain sockets. *)
and connect_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Initial call to connect(2) on the socket";
    external_events = [ NotifyWrite, "CONNECTING" ];
  };

  State {
    default_state with
    name = "CONNECTING";
    comment = "Connecting to the remote server";
    external_events = [ NotifyWrite, "" ];
  };
]

(* State machine implementing [nbd_aio_connect_tcp]. *)
and connect_tcp_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Connect to a remote TCP server";
    external_events = [];
  };

  State {
    default_state with
    name = "CONNECT";
    comment = "Initial call to connect(2) on a TCP socket";
    external_events = [ NotifyWrite, "CONNECTING" ];
  };

  State {
    default_state with
    name = "CONNECTING";
    comment = "Connecting to the remote server over a TCP socket";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "NEXT_ADDRESS";
    comment = "Connecting to the next address over a TCP socket";
    external_events = [];
  };
]

(* State machine implementing [nbd_aio_connect_command]. *)
and connect_command_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Connect to a subprocess";
    external_events = [];
  };
]

(* Parse initial magic string from the server. *)
and magic_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Prepare to receive the magic identification from remote";
    external_events = [];
  };

  State {
    default_state with
    name = "RECV_MAGIC";
    comment = "Receive initial magic identification from remote";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "CHECK_MAGIC";
    comment = "Check magic and version sent by remote";
  };
]

(* Oldstyle handshake. *)
and oldstyle_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Prepare to receive remainder of oldstyle header";
    external_events = [];
  };

  State {
    default_state with
    name = "RECV_REMAINING";
    comment = "Receive remainder of oldstyle header";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "CHECK";
    comment = "Check oldstyle header";
    external_events = [];
  };
]

(* Fixed newstyle handshake. *)
and newstyle_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Prepare to receive newstyle gflags from remote";
    external_events = [];
  };

  State {
    default_state with
    name = "RECV_GFLAGS";
    comment = "Receive newstyle gflags from remote";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "CHECK_GFLAGS";
    comment = "Check global flags sent by remote";
  };

  State {
    default_state with
    name = "SEND_CFLAGS";
    comment = "Send newstyle client flags to remote";
    external_events = [ NotifyWrite, "" ];
  };

  (* Options.  These state groups are always entered unconditionally,
   * in this order.  The START state in each group will check if the
   * state needs to run and skip to the next state in the list if not.
   *)
  Group ("OPT_STARTTLS", newstyle_opt_starttls_state_machine);
  Group ("OPT_STRUCTURED_REPLY", newstyle_opt_structured_reply_state_machine);
  Group ("OPT_SET_META_CONTEXT", newstyle_opt_set_meta_context_state_machine);
  Group ("OPT_GO", newstyle_opt_go_state_machine);
  Group ("OPT_EXPORT_NAME", newstyle_opt_export_name_state_machine);
]

(* Fixed newstyle NBD_OPT_STARTTLS option. *)
and newstyle_opt_starttls_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Try to send newstyle NBD_OPT_STARTTLS to upgrade to TLS";
    external_events = [];
  };

  State {
    default_state with
    name = "SEND";
    comment = "Send newstyle NBD_OPT_STARTTLS to upgrade to TLS";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "RECV_REPLY";
    comment = "Receive newstyle NBD_OPT_STARTTLS reply";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "SKIP_REPLY_PAYLOAD";
    comment = "Skip newstyle NBD_OPT_STARTTLS reply payload";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "CHECK_REPLY";
    comment = "Check newstyle NBD_OPT_STARTTLS reply";
    external_events = [];
  };

  State {
    default_state with
    name = "TLS_HANDSHAKE_READ";
    comment = "TLS handshake (reading)";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "TLS_HANDSHAKE_WRITE";
    comment = "TLS handshake (writing)";
    external_events = [ NotifyWrite, "" ];
  };
]

(* Fixed newstyle NBD_OPT_STRUCTURED_REPLY option. *)
and newstyle_opt_structured_reply_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Try to negotiate newstyle NBD_OPT_STRUCTURED_REPLY";
    external_events = [];
  };

  State {
    default_state with
    name = "SEND";
    comment = "Send newstyle NBD_OPT_STRUCTURED_REPLY negotiation request";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "RECV_REPLY";
    comment = "Receive newstyle NBD_OPT_STRUCTURED_REPLY option reply";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "SKIP_REPLY_PAYLOAD";
    comment = "Skip newstyle NBD_OPT_STRUCTURED_REPLY reply payload";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "CHECK_REPLY";
    comment = "Check newstyle NBD_OPT_STRUCTURED_REPLY option reply";
    external_events = [];
  };
]

(* Fixed newstyle NBD_OPT_SET_META_CONTEXT option. *)
and newstyle_opt_set_meta_context_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Try to negotiate newstyle NBD_OPT_SET_META_CONTEXT";
    external_events = [];
  };

  State {
    default_state with
    name = "SEND";
    comment = "Send newstyle NBD_OPT_SET_META_CONTEXT";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "SEND_EXPORTNAMELEN";
    comment = "Send newstyle NBD_OPT_SET_META_CONTEXT export name length";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "SEND_EXPORTNAME";
    comment = "Send newstyle NBD_OPT_SET_META_CONTEXT export name";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "SEND_NRQUERIES";
    comment = "Send newstyle NBD_OPT_SET_META_CONTEXT number of queries";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "PREPARE_NEXT_QUERY";
    comment = "Prepare to send newstyle NBD_OPT_SET_META_CONTEXT query";
    external_events = [];
  };

  State {
    default_state with
    name = "SEND_QUERYLEN";
    comment = "Send newstyle NBD_OPT_SET_META_CONTEXT query length";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "SEND_QUERY";
    comment = "Send newstyle NBD_OPT_SET_META_CONTEXT query";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "PREPARE_FOR_REPLY";
    comment = "Prepare to receive newstyle NBD_OPT_SET_META_CONTEXT option reply";
    external_events = [];
  };

  State {
    default_state with
    name = "RECV_REPLY";
    comment = "Receive newstyle NBD_OPT_SET_META_CONTEXT option reply";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "RECV_REPLY_PAYLOAD";
    comment = "Receive newstyle NBD_OPT_SET_META_CONTEXT option reply payload";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "RECV_SKIP_PAYLOAD";
    comment = "Ignore newstyle NBD_OPT_SET_META_CONTEXT option reply payload";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "FINISH";
    comment = "Finish newstyle NBD_OPT_SET_META_CONTEXT option parsing";
    external_events = [];
  };
]

(* Fixed newstyle NBD_OPT_GO option. *)
and newstyle_opt_go_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Try to send newstyle NBD_OPT_GO to end handshake";
    external_events = [];
  };

  State {
    default_state with
    name = "SEND";
    comment = "Send newstyle NBD_OPT_GO to end handshake";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "SEND_EXPORTNAMELEN";
    comment = "Send newstyle NBD_OPT_GO export name length";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "SEND_EXPORT";
    comment = "Send newstyle NBD_OPT_GO export name";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "SEND_NRINFOS";
    comment = "Send newstyle NBD_OPT_GO number of infos";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "RECV_REPLY";
    comment = "Receive newstyle NBD_OPT_GO reply";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "RECV_REPLY_PAYLOAD";
    comment = "Receive newstyle NBD_OPT_GO reply payload";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "CHECK_REPLY";
    comment = "Check newstyle NBD_OPT_GO reply";
    external_events = [];
  };
]

(* Newstyle NBD_OPT_EXPORT_NAME option. *)
and newstyle_opt_export_name_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Try to send newstyle NBD_OPT_EXPORT_NAME to end handshake";
    external_events = [];
  };

  State {
    default_state with
    name = "SEND";
    comment = "Send newstyle NBD_OPT_EXPORT_NAME to end handshake";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "SEND_EXPORT";
    comment = "Send newstyle NBD_OPT_EXPORT_NAME export name";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "RECV_REPLY";
    comment = "Receive newstyle NBD_OPT_EXPORT_NAME reply";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "CHECK_REPLY";
    comment = "Check newstyle NBD_OPT_EXPORT_NAME reply";
    external_events = [];
  };
]

(* Sending a command to the server. *)
and issue_command_state_machine = [
  State {
    default_state with
    name = "START";
    (* XXX There's a possible deadlock here if a server cannot
     * handle multiple requests pipelined on a single connection.
     * We could try to issue a command and block, but reads might
     * be available.  It should be possible to break this with
     * another state.
     *)
    comment = "Begin issuing a command to the remote server";
    external_events = [];
  };

  State {
    default_state with
    name = "SEND_REQUEST";
    comment = "Sending a request to the remote server";
    external_events = [ NotifyWrite, "" ];
  };

  State {
    default_state with
    name = "SEND_WRITE_PAYLOAD";
    comment = "Sending the write payload to the remote server";
    external_events = [ NotifyWrite, "" ];
  };
]

(* Receiving a reply from the server. *)
and reply_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Prepare to receive a reply from the remote server";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "RECV_REPLY";
    comment = "Receive a reply from the remote server";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "CHECK_SIMPLE_OR_STRUCTURED_REPLY";
    comment = "Check if the reply is a simple or structured reply";
    external_events = [];
  };

  Group ("SIMPLE_REPLY", simple_reply_state_machine);
  Group ("STRUCTURED_REPLY", structured_reply_state_machine);

  State {
    default_state with
    name = "FINISH_COMMAND";
    comment = "Finish receiving a command";
    external_events = [];
  };
]

(* Receiving a simple reply from the server. *)
and simple_reply_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Parse a simple reply from the server";
    external_events = [];
  };

  State {
    default_state with
    name = "RECV_READ_PAYLOAD";
    comment = "Receiving the read payload for a simple reply";
    external_events = [ NotifyRead, "" ];
  };
]

(* Receiving a structured reply from the server. *)
and structured_reply_state_machine = [
  State {
    default_state with
    name = "START";
    comment = "Prepare to receive the remaining part of a structured reply";
    external_events = [];
  };

  State {
    default_state with
    name = "RECV_REMAINING";
    comment = "Receiving the remaining part of a structured reply";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "CHECK";
    comment = "Parse a structured reply from the server";
    external_events = [];
  };

  State {
    default_state with
    name = "RECV_ERROR";
    comment = "Receive a structured reply error header";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "RECV_ERROR_MESSAGE";
    comment = "Receive a structured reply error message";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "RECV_OFFSET_DATA";
    comment = "Receive a structured reply offset-data header";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "RECV_OFFSET_DATA_DATA";
    comment = "Receive a structured reply offset-data block of data";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "RECV_OFFSET_HOLE";
    comment = "Receive a structured reply offset-hole header";
    external_events = [ NotifyRead, "" ];
  };

  State {
    default_state with
    name = "RECV_BS_ENTRIES";
    comment = "Receive a structured reply block-status payload";
    external_events = [ NotifyRead, "" ];
  };
]

(*----------------------------------------------------------------------*)

(* The API. *)

type call = {
  args : arg list;         (* parameters (except handle) *)
  ret : ret;               (* return value *)
  is_locked : bool;        (* most functions need to take a lock *)
  shortdesc : string;      (* short description *)
  longdesc : string;       (* long description *)
}
and arg =
| ArrayAndLen of arg * string (* array + number of entries *)
| Bool of string           (* bool *)
| BytesIn of string * string (* byte array + size passed in to the function *)
| BytesOut of string * string(* byte array + size specified by caller,
                              written by the function *)
| Callback of string * arg list (* callback function returning void *)
| Int of string            (* small int *)
| Int64 of string          (* 64 bit signed int *)
| Opaque of string         (* opaque object, void* in C *)
| Path of string           (* filename or path *)
| SockAddrAndLen of string * string (* struct sockaddr * + socklen_t *)
| String of string         (* string *)
| StringList of string     (* argv-style NULL-terminated array of strings *)
| UInt of string           (* small unsigned int *)
| UInt32 of string         (* 32 bit unsigned int *)
| UInt64 of string         (* 64 bit unsigned int *)
and ret =
| RBool                    (* return a boolean, or error *)
| RConstString             (* return a const string, NULL for error *)
| RErr                     (* return 0 = ok, -1 = error *)
| RFd                      (* return a file descriptor, or error *)
| RInt                     (* return a small int, -1 = error *)
| RInt64                   (* 64 bit int, -1 = error *)
| RString                  (* return a newly allocated string, caller frees *)

let default_call = { args = []; ret = RErr; is_locked = true;
                     shortdesc = ""; longdesc = "" }

(* Calls on [nbd_handle *nbd] *)
let handle_calls = [
  "set_debug", {
    default_call with
    args = [ Bool "debug" ]; ret = RErr;
    shortdesc = "set or clear the debug flag";
    longdesc = "\
Set or clear the debug flag.  When debugging is enabled,
debugging messages from the library are printed to stderr,
unless a debugging callback has been defined too
(see C<nbd_set_debug_callback>) in which case they are
sent to that function.  This flag defaults to false on
newly created handles, except if C<LIBNBD_DEBUG=1> is
set in the environment in which case it defaults to true.";
  };

  "get_debug", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "return the state of the debug flag";
    longdesc = "\
Return the state of the debug flag on this handle.";
  };

  "set_debug_callback", {
    default_call with
    args = [ Opaque "data";
             Callback ("debug_fn", [Opaque "data";
                                    String "context"; String "msg"]) ];
    ret = RErr;
    shortdesc = "set the debug callback";
    longdesc = "\
Set the debug callback.  This function is called when the library
emits debug messages, when debugging is enabled on a handle.  The
callback parameters are C<id> passed to this function, the
name of the libnbd function emitting the debug message (C<context>),
and the message itself (C<msg>).  If no debug callback is set on
a handle then messages are printed on C<stderr>.";
  };

  "set_export_name", {
    default_call with
    args = [ String "export_name" ]; ret = RErr;
    shortdesc = "set the export name";
    longdesc = "\
For servers which require an export name or can serve different
content on different exports, set the C<export_name> to
connect to.  This is only relevant for the newstyle protocol,
and you must set this before connecting.  The default is to
use the empty string.";
  };

  "get_export_name", {
    default_call with
    args = []; ret = RString;
    shortdesc = "get the export name";
    longdesc = "\
Get the export name associated with the handle.";
  };

  "set_multi_conn", {
    default_call with
    args = [ UInt "multi_conn" ]; ret = RErr;
    shortdesc = "enable or disable multi-conn and set nr connections";
    longdesc = "\
NBD can make multiple connections, if the server supports it.
The C<multi_conn> parameter controls whether this feature is
enabled (if E<gt> 1) or disabled (if C<1>).  The parameter
passed must not be C<0>.  Usually small powers of 2 (eg. 2, 4, 8)
will provide increments in performance.  Some servers do not
support this feature and will return an error on connection.

At present, libnbd assumes that all connections will report the
same capabilities; a server that behaves otherwise may trigger
unexpected behavior.";
  };

  "get_multi_conn", {
    default_call with
    args = []; ret = RInt;
    shortdesc = "get the multi-conn setting";
    longdesc = "\
Get the multi-conn setting for this handle.  This is always E<ge> 1,
where 1 means multi-conn is not enabled.";
  };

  "set_tls", {
    default_call with
    args = [Int "tls"]; ret = RErr;
    shortdesc = "enable or require TLS (authentication and encryption)";
    longdesc = "\
Enable or require TLS (authenticated and encrypted connections) to the
NBD server.  The possible settings are:

=over 4

=item C<tls=0>

Disable TLS.  (The default setting)

=item C<tls=1>

Enable TLS if possible.  In some cases this will fall back
to an unencrypted and/or unauthenticated connection if
TLS could not be established.  However some servers will
drop the connection if TLS fails so fallback may not be
possible.

=item C<tls=2>

Require an encrypted and authenticated TLS connection.
Always fail to connect if the connection is not encrypted
and authenticated.

=back

As well as calling this you may also need to supply
the path to the certificates directory (C<nbd_set_tls_certificates>),
the username (C<nbd_set_tls_username>) and/or
the Pre-Shared Keys (PSK) file (C<nbd_set_tls_psk_file>).

For more information see L<libnbd(3)/ENCRYPTION AND AUTHENTICATION>.";
  };

  "get_tls", {
    default_call with
    args = []; ret = RInt;
    shortdesc = "Get the current TLS setting";
    longdesc = "\
Get the current TLS setting.  See C<nbd_set_tls>.";
  };

  "set_tls_certificates", {
    default_call with
    args = [Path "dir"]; ret = RErr;
    shortdesc = "set the path to the TLS certificates directory";
    longdesc = "\
Set the path to the TLS certificates directory.  If not
set and TLS is used then a compiled in default is used.
For root this is C</etc/pki/libnbd/>.  For non-root this is
C<$HOME/.pki/libnbd> and C<$HOME/.config/pki/libnbd>.  If
none of these directories can be found then the system
trusted CAs are used.";
  };

(* Can't implement this because we need a way to return string that
   can be NULL.
  "get_tls_certificates", {
    default_call with
    args = []; ret = RString;
    shortdesc = "Get the current TLS certificates directory";
    longdesc = "\
Get the current TLS directory.  See C<nbd_set_tls_certificates>.";
  };
*)

  "set_tls_verify_peer", {
    default_call with
    args = [Bool "verify"]; ret = RErr;
    shortdesc = "set whether we verify the identity of the server";
    longdesc = "\
Set this flag to control whether libnbd will verify the identity
of the server from the server's certificate and the certificate
authority.  This defaults to true when connecting to TCP servers
using TLS certificate authentication, and false otherwise.";
  };

  "get_tls_verify_peer", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "get whether we verify the identity of the server";
    longdesc = "\
Get the verify peer flag.";
  };

  "set_tls_username", {
    default_call with
    args = [String "username"]; ret = RErr;
    shortdesc = "set the TLS username";
    longdesc = "\
Set the TLS client username.  This is used
if authenticating with PSK over TLS is enabled.
If not set then the local username is used.";
  };

  "get_tls_username", {
    default_call with
    args = []; ret = RString;
    shortdesc = "get the current TLS username";
    longdesc = "\
Get the current TLS username.  See C<nbd_set_tls_username>.";
  };

  "set_tls_psk_file", {
    default_call with
    args = [Path "filename"]; ret = RErr;
    shortdesc = "set the TLS Pre-Shared Keys (PSK) filename";
    longdesc = "\
Set the TLS Pre-Shared Keys (PSK) filename.  This is used
if trying to authenticate to the server using with a pre-shared
key.  There is no default so if this is not set then PSK
authentication cannot be used to connect to the server.";
  };

(* Can't implement this because we need a way to return string that
   can be NULL.
  "get_tls_psk_file", {
    default_call with
    args = []; ret = RString;
    shortdesc = "get the current TLS PSK filename";
    longdesc = "\
Get the current TLS PSK filename.  See C<nbd_set_tls_psk_file>.";
  };
*)

  "request_meta_context", {
    default_call with
    args = [ String "name" ]; ret = RErr;
    shortdesc = "request metadata context from the server";
    longdesc = "\
This is used to enable a metadata context on the server.  This
can be used to allow you to read extra information about
data blocks, such as whether they are sparse (holes) or
allocated, and dirty bitmaps.  You must call this before you
connect to the server because metadata context negotiation
happens during the initial handshake.  To learn if a context
was actually negotiated, use C<nbd_can_meta_context> after
the connection is ready.

The single parameter is the name of the metadata context,
for example C<\"base:allocation\">.

Other metadata contexts are server-specific, but include
C<\"qemu:dirty-bitmap:...\"> for qemu-nbd
(see qemu-nbd I<-B> option).  See also C<nbd_block_status>.";
  };

  "connect_unix", {
    default_call with
    args = [ Path "sockpath" ]; ret = RErr;
    shortdesc = "connect to NBD server over a Unix domain socket";
    longdesc = "\
Connect (synchronously) over the named Unix domain socket (C<sockpath>)
to an NBD server running on the same machine.  This call returns
when the connection has been made.  If multi-conn is enabled, this
returns when all of the connections are connected.";
  };

  "connect_tcp", {
    default_call with
    args = [ String "hostname"; String "port" ]; ret = RErr;
    shortdesc = "connect to NBD server over a TCP port";
    longdesc = "\
Connect (synchronously) to the NBD server listening on
C<hostname:port>.  The C<port> may be a port name such
as C<\"nbd\">, or it may be a port number as a string
such as C<\"10809\">.  This call returns when the connection
has been made.  If multi-conn is enabled, this returns when
all of the connections are connected.";
  };

  "connect_command", {
    default_call with
    args = [ StringList "argv" ]; ret = RErr;
    shortdesc = "connect to NBD server command";
    longdesc = "\
Run the command as a subprocess and connect to it over
stdin/stdout.  This is for use with NBD servers which can
behave like inetd clients, such as C<nbdkit --single>.";
  };

  "read_only", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "is the NBD export read-only?";
    longdesc = "\
Returns true if the NBD export is read-only; writes and
write-like operations will fail.  Can return an error if we have not
connected to and completed the handshake with the server.";
  };

  "can_flush", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "does the server support the flush command?";
    longdesc = "\
Returns true if the server supports the flush command
(see C<nbd_flush>, C<nbd_aio_flush>).  Returns false if
the server does not.  Can return an error if we have not
connected to and completed the handshake with the server.";
  };

  "can_fua", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "does the server support the FUA flag?";
    longdesc = "\
Returns true if the server supports the FUA flag on
certain commands (see C<nbd_pwrite>).  Can return an error
if we have not connected to and completed the handshake with the server.";
  };

  "is_rotational", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "is the NBD disk rotational (like a disk)?";
    longdesc = "\
Returns true if the disk exposed over NBD is rotational
(like a traditional floppy or hard disk).  Returns false if
the disk has no penalty for random access (like an SSD or
RAM disk).  Can return an error if we have not connected
to and completed the handshake with the server.";
  };

  "can_trim", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "does the server support the trim command?";
    longdesc = "\
Returns true if the server supports the trim command
(see C<nbd_trim>, C<nbd_aio_trim>).  Returns false if
the server does not.  Can return an error if we have not
connected to and completed the handshake with the server.";
  };

  "can_zero", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "does the server support the zero command?";
    longdesc = "\
Returns true if the server supports the zero command
(see C<nbd_zero>, C<nbd_aio_zero>).  Returns false if
the server does not.  Can return an error if we have not
connected to and completed the handshake with the server.";
  };

  "can_multi_conn", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "does the server support multi-conn?";
    longdesc = "\
Returns true if the server supports multi-conn
(see C<nbd_set_multi_conn>).  Returns false if
the server does not.  Can return an error if we have not
connected to and completed the handshake with the server.";
  };

  "can_cache", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "does the server support the cache command?";
    longdesc = "\
Returns true if the server supports the cache command
(see C<nbd_cache>, C<nbd_aio_cache>).  Returns false if
the server does not.  Can return an error if we have not
connected to and completed the handshake with the server.";
  };

  "can_meta_context", {
    default_call with
    args = [String "metacontext"]; ret = RBool;
    shortdesc = "does the server support a specific meta context?";
    longdesc = "\
Returns true if the server supports the given meta context
(see C<nbd_request_meta_context>).  Returns false if
the server does not.  Can return an error if we have not
connected to and completed the handshake with the server.

The single parameter is the name of the metadata context,
for example C<\"base:allocation\">.";
  };

  "get_size", {
    default_call with
    args = []; ret = RInt64;
    shortdesc = "return the export size";
    longdesc = "\
Returns the size in bytes of the NBD export.  Can return an
error if we have not connected to and completed the handshake
with the server.";
  };

  "pread", {
    default_call with
    args = [ BytesOut ("buf", "count"); UInt64 "offset" ];
    ret = RErr;
    shortdesc = "read from the NBD server";
    longdesc = "\
Issue a read command to the NBD server for the range starting
at C<offset> and ending at C<offset> + C<count> - 1.  NBD
can only read all or nothing using this call.  The call
returns when the data has been read fully into C<buf> or there is an
error.

If multi-conn is enabled, the command is issued on the next
ready connection, picked in a round-robin manner.";
  };

  "pwrite", {
    default_call with
    args = [ BytesIn ("buf", "count"); UInt64 "offset"; UInt32 "flags" ];
    ret = RErr;
    shortdesc = "write to the NBD server";
    longdesc = "\
Issue a write command to the NBD server, writing the data in
C<buf> to the range starting at C<offset> and ending at
C<offset> + C<count> - 1.  NBD can only write all or nothing
using this call.  The call returns when the command has been
acknowledged by the server, or there is an error.

The C<flags> parameter may be C<0> for no flags, or may contain
C<LIBNBD_CMD_FLAG_FUA> meaning that the server should not
return until the data has been committed to permanent storage
(if that is supported - some servers cannot do this).

If multi-conn is enabled, the command is issued on the next
ready connection, picked in a round-robin manner.";
  };

  "shutdown", {
    default_call with
    args = []; ret = RErr;
    shortdesc = "disconnect from the NBD server";
    longdesc = "\
Issue the disconnect command to the NBD server.  This is
a nice way to tell the server we are going away, but from the
client's point of view has no advantage over abruptly closing
the connection (see C<nbd_close>).";
  };

  "flush", {
    default_call with
    args = []; ret = RErr;
    shortdesc = "flushing pending write requests";
    longdesc = "\
Issue the flush command to the NBD server.  The function should
return when all write commands which have completed have been
committed to permanent storage on the server.  Note this will
return an error if C<nbd_can_flush> is false.";
  };

  "trim", {
    default_call with
    args = [ UInt64 "count"; UInt64 "offset"; UInt32 "flags" ];
    ret = RErr;
    shortdesc = "send trim to the NBD server";
    longdesc = "\
Issue a trim command to the NBD server, which if supported
by the server causes a hole to be punched in the backing
store starting at C<offset> and ending at C<offset> + C<count> - 1.
The call returns when the command has been acknowledged by the server,
or there is an error.

The C<flags> parameter may be C<0> for no flags, or may contain
C<LIBNBD_CMD_FLAG_FUA> meaning that the server should not
return until the data has been committed to permanent storage
(if that is supported - some servers cannot do this).

If multi-conn is enabled, the command is issued on the next
ready connection, picked in a round-robin manner.";
  };

  "cache", {
    default_call with
    args = [ UInt64 "count"; UInt64 "offset" ];
    ret = RErr;
    shortdesc = "send cache (prefetch) to the NBD server";
    longdesc = "\
Issue the cache (prefetch) command to the NBD server, which
if supported by the server causes data to be prefetched
into faster storage by the server, speeding up a subsequent
C<nbd_pread> call.  The server can also silently ignore
this command.  Note this will return an error if
C<nbd_can_cache> is false.";
  };

  "zero", {
    default_call with
    args = [ UInt64 "count"; UInt64 "offset"; UInt32 "flags" ];
    ret = RErr;
    shortdesc = "send write zeroes to the NBD server";
    longdesc = "\
Issue a write zeroes command to the NBD server, which if supported
by the server causes a zeroes to be written efficiently
starting at C<offset> and ending at C<offset> + C<count> - 1.
The call returns when the command has been acknowledged by the server,
or there is an error.

The C<flags> parameter may be C<0> for no flags, or may contain
C<LIBNBD_CMD_FLAG_FUA> meaning that the server should not
return until the data has been committed to permanent storage
(if that is supported - some servers cannot do this).

If multi-conn is enabled, the command is issued on the next
ready connection, picked in a round-robin manner.";
  };

  "block_status", {
    default_call with
    args = [ UInt64 "count"; UInt64 "offset"; UInt32 "flags";
             Opaque "data";
             Callback ("extent", [Opaque "data"; String "metacontext";
                                  UInt64 "offset";
                                  ArrayAndLen (UInt32 "entries",
                                               "nr_entries")]) ];
    ret = RErr;
    shortdesc = "read the block status of the given range";
    longdesc = "\
Issue the block status command to the NBD server.  If
supported by the server, this causes metadata context
information about blocks beginning from the specified
offset to be returned. The C<count> parameter is a hint: the
server may choose to return less status, or the final block
may extend beyond the requested range. If multiple contexts
are supported, the number of blocks and cumulative length
of those blocks need not be identical between contexts.

Depending on which metadata contexts were enabled before
connecting (see C<nbd_request_meta_context>) and which are
supported by the server (see C<nbd_can_meta_context>) this call
returns information about extents by calling back to the
extent function. The callback should B<not> call any C<nbd_*>
library functions, as this could trigger deadlock.

The extent function is called once per type of metadata
available.  The C<metacontext> parameter is a string
such as C<\"base:allocation\">.  The C<entries> array
is an array of pairs of integers with the first entry
in each pair being the length (in bytes) of the block
and the second entry being a status/flags field which
is specific to the metadata context.  (The number of
pairs passed to the function is C<nr_entries/2>.)
The NBD protocol document in the section about
C<NBD_REPLY_TYPE_BLOCK_STATUS> describes the meaning
of this array.

It is possible for the extent function to be called
more times than you expect (if the server is buggy),
so always check the C<metacontext> field to ensure you
are receiving the data you expect.  It is also possible
that the extent function is not called at all, even for
metadata contexts that you requested.  This indicates
either that the server doesn't support the context
or for some other reason cannot return the data.

The C<flags> parameter may be C<0> for no flags, or may contain
C<LIBNBD_CMD_FLAG_REQ_ONE> meaning that the server should
return only one extent per metadata context where that extent
does not exceed C<count> bytes; however, libnbd does not
validate that the server obeyed the flag.";
  };

  "poll", {
    default_call with
    args = [ Int "timeout" ]; ret = RErr;
    shortdesc = "poll the handle once";
    longdesc = "\
This is a simple implementation of L<poll(2)> which is used
internally by synchronous API calls.  It is mainly useful as
an example of how you might integrate libnbd with your own
main loop, rather than being intended as something you would use.";
  };
]

(* Calls on [nbd_connection *conn] *)
let connection_calls = [
  "aio_connect", {
    default_call with
    args = [ SockAddrAndLen ("addr", "addrlen") ]; ret = RErr;
    shortdesc = "connect to the NBD server";
    longdesc = "\
Begin connecting to the NBD server.

You can check if the connection is still connecting by calling
C<nbd_aio_is_connecting>, or if it has connected to the server
and completed the NBD handshake by calling C<nbd_aio_is_ready>,
on the connection.";
  };

  "aio_connect_tcp", {
    default_call with
    args = [ String "hostname"; String "port" ]; ret = RErr;
    shortdesc = "connect to the NBD server over a TCP port";
    longdesc = "\
Begin connecting to the NBD server listening on C<hostname:port>.

You can check if the connection is still connecting by calling
C<nbd_aio_is_connecting>, or if it has connected to the server
and completed the NBD handshake by calling C<nbd_aio_is_ready>,
on the connection.";
  };

  "aio_connect_command", {
    default_call with
    args = [ StringList "argv" ]; ret = RErr;
    shortdesc = "connect to the NBD server";
    longdesc = "\
Run the command as a subprocess and begin connecting to it over
stdin/stdout.

You can check if the connection is still connecting by calling
C<nbd_aio_is_connecting>, or if it has connected to the server
and completed the NBD handshake by calling C<nbd_aio_is_ready>,
on the connection.";
  };

  "aio_pread", {
    default_call with
    args = [ BytesOut ("buf", "count"); UInt64 "offset" ];
    ret = RInt64;
    shortdesc = "read from the NBD server";
    longdesc = "\
Issue a read command to the NBD server.  This returns the
unique 64 bit handle for this command.  To check if the command
completed, call C<nbd_aio_command_completed>.  Note that
you must ensure C<buf> is valid until the command has
completed.";
  };

  "aio_pwrite", {
    default_call with
    args = [ BytesIn ("buf", "count"); UInt64 "offset"; UInt32 "flags" ];
    ret = RInt64;
    shortdesc = "write to the NBD server";
    longdesc = "\
Issue a write command to the NBD server.  This returns the
unique 64 bit handle for this command.  To check if the command
completed, call C<nbd_aio_command_completed>.  Note that
you must ensure C<buf> is valid until the command has
completed.";
  };

  "aio_disconnect", {
    default_call with
    args = []; ret = RErr;
    shortdesc = "disconnect from the NBD server";
    longdesc = "\
Issue the disconnect command to the NBD server.  This is
not a normal command because NBD servers are not obliged
to send a reply.  Instead you should wait for
C<nbd_aio_is_closed> to become true on the connection.";
  };

  "aio_flush", {
    default_call with
    args = []; ret = RInt64;
    shortdesc = "disconnect from the NBD server";
    longdesc = "\
Issue the flush command to the NBD server.  This returns the
unique 64 bit handle for this command.  To check if the command
completed, call C<nbd_aio_command_completed>.";
  };

  "aio_trim", {
    default_call with
    args = [ UInt64 "count"; UInt64 "offset"; UInt32 "flags" ];
    ret = RInt64;
    shortdesc = "send trim to the NBD server";
    longdesc = "\
Issue a trim command to the NBD server.  This returns the
unique 64 bit handle for this command.  To check if the command
completed, call C<nbd_aio_command_completed>.";
  };

  "aio_cache", {
    default_call with
    args = [ UInt64 "count"; UInt64 "offset" ];
    ret = RInt64;
    shortdesc = "send cache (prefetch) to the NBD server";
    longdesc = "\
Issue the cache (prefetch) command to the NBD server.  This
returns the unique 64 bit handle for this command.  To check
if the command completed, call C<nbd_aio_command_completed>.  ";
  };

  "aio_zero", {
    default_call with
    args = [ UInt64 "count"; UInt64 "offset"; UInt32 "flags" ];
    ret = RInt64;
    shortdesc = "send write zeroes to the NBD server";
    longdesc = "\
Issue a write zeroes command to the NBD server.  This returns the
unique 64 bit handle for this command.  To check if the command
completed, call C<nbd_aio_command_completed>.";
  };

  "aio_block_status", {
    default_call with
    args = [ UInt64 "count"; UInt64 "offset"; UInt32 "flags";
             Opaque "data";
             Callback ("extent", [Opaque "data"; String "metacontext";
                                  UInt64 "offset";
                                  ArrayAndLen (UInt32 "entries",
                                               "nr_entries")]) ];
    ret = RInt64;
    shortdesc = "send block status to the NBD server";
    longdesc = "\
Send the block status command to the NBD server.  This returns the
unique 64 bit handle for this command.  To check if the command
completed, call C<nbd_aio_command_completed>.";
  };

  "aio_get_fd", {
    default_call with
    args = []; ret = RFd;
    shortdesc = "return file descriptor associated with this connection";
    longdesc = "\
Return the underlying file descriptor associated with this
connection.  You can use this to check if the file descriptor
is ready for reading or writing and call C<nbd_aio_notify_read>
or C<nbd_aio_notify_write>.  See also C<nbd_aio_get_direction>.
Do not do anything else with the file descriptor.";
  };

  "aio_get_direction", {
    default_call with
    args = []; ret = RErr;
    shortdesc = "return the read or write direction";
    longdesc = "\
Return the current direction of this connection, which means
whether we are next expecting to read data from the server, write
data to the server, or both.  It returns

=over 4

=item C<LIBNBD_AIO_DIRECTION_READ> = 1

We are expected next to read from the server.  If using L<poll(2)>
you would set C<events = POLLIN>.  If C<revents> returns C<POLLIN>
you would then call C<nbd_aio_notify_read>.

=item C<LIBNBD_AIO_DIRECTION_WRITE> = 2

We are expected next to write to the server.  If using L<poll(2)>
you would set C<events = POLLOUT>.  If C<revents> returns C<POLLOUT>
you would then call C<nbd_aio_notify_write>.

=item C<LIBNBD_AIO_DIRECTION_BOTH> = 3

We are expected next to either read or write to the server.
If using L<poll(2)> you would set C<events = POLLIN|POLLOUT>.
If one of C<POLLIN> or C<POLLOUT> is returned, then see above.
However note that you shouldn't call C<nbd_aio_notify_read>
and C<nbd_aio_notify_write> because calling the first one will
change the state of the connection, possibly invalidating the second
notification.

=back";
  };

  "aio_notify_read", {
    default_call with
    args = []; ret = RErr;
    shortdesc = "notify that the connection is readable";
    longdesc = "\
Send notification to the state machine that the connection
is readable.  Typically this is called after your main loop
has detected that the file descriptor associated with this
connection is readable.";
  };

  "aio_notify_write", {
    default_call with
    args = []; ret = RErr;
    shortdesc = "notify that the connection is writable";
    longdesc = "\
Send notification to the state machine that the connection
is writable.  Typically this is called after your main loop
has detected that the file descriptor associated with this
connection is writable.";
  };

  "aio_is_created", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "check if the connection has just been created";
    longdesc = "\
Return true if this connection has just been created.  This
is the state before the connection object has started
connecting to a server.  In this state the handle can start
to be connected by calling functions such as C<nbd_aio_connect>.";
  };

  "aio_is_connecting", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "check if the connection is connecting or handshaking";
    longdesc = "\
Return true if this connection is connecting to the server
or in the process of handshaking and negotiating options
which happens before the connection object becomes ready to
issue commands (see C<nbd_aio_is_ready>).";
  };

  "aio_is_ready", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "check if the connection is in the ready state";
    longdesc = "\
Return true if this connection is connected to the NBD server,
the handshake has completed, and the connection is idle or
waiting for a reply.  In this state the handle is ready to
issue commands.";
  };

  "aio_is_processing", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "check if the connection is processing a command";
    longdesc = "\
Return true if this connection is connected to the NBD server,
the handshake has completed, and the connection is processing
commands (either writing out a request or reading a reply).

Note the ready state (C<nbd_aio_is_ready>) is not included.
In the ready state commands may be I<in flight> (the I<server>
is processing them), but libnbd is not processing them.";
  };

  "aio_is_dead", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "check if the connection is dead";
    longdesc = "\
Return true if the connection has encountered a fatal
error and is dead.  In this state the connection (or whole handle)
may only be closed.  There is no way to recover a handle from
the dead state.";
  };

  "aio_is_closed", {
    default_call with
    args = []; ret = RBool;
    shortdesc = "check if the connection is closed";
    longdesc = "\
Return true if the connection has closed.  There is no way to
reconnect a closed connection.  Instead you must recreate the
connection object or close the whole handle.";
  };

  "aio_command_completed", {
    default_call with
    args = [Int64 "handle"]; ret = RBool;
    shortdesc = "check if the command completed";
    longdesc = "\
Return true if the command completed.  If this function returns
true then the command was successful and it has been retired.
Return false if the command is still in flight.  This can also
fail with an error in case the command failed (in this case
the command is also retired).

The C<handle> parameter is the unique 64 bit handle for the command,
as returned by a call such as C<nbd_aio_pread>.";
  };

  "connection_state", {
    default_call with
    args = []; ret = RConstString;
    shortdesc = "return a descriptive string for the state of the connection";
    longdesc = "\
Returns a descriptive string for the state of the connection.  This
can be used for debugging or troubleshooting, but you should not
rely on the state of connections since it may change in future
versions.";
  };
]

(*----------------------------------------------------------------------*)

(* Helper functions. *)

let failwithf fs = ksprintf failwith fs

let rec filter_map f = function
  | [] -> []
  | x :: xs ->
      match f x with
      | Some y -> y :: filter_map f xs
      | None -> filter_map f xs

let chan = ref Pervasives.stdout
let pr fs = ksprintf (fun str -> output_string !chan str) fs

type comment_style =
  | CStyle | CPlusPlusStyle | HashStyle | OCamlStyle | HaskellStyle
  | PODCommentStyle

let generate_header ?(extra_sources = []) comment_style =
  let inputs = "generator/generator" :: extra_sources in
  let c = match comment_style with
    | CStyle ->         pr "/* "; " *"
    | CPlusPlusStyle -> pr "// "; "//"
    | HashStyle ->      pr "# ";  "#"
    | OCamlStyle ->     pr "(* "; " *"
    | HaskellStyle ->   pr "{- "; "  "
    | PODCommentStyle -> pr "=begin comment\n\n "; "" in
  pr "NBD client library in userspace\n";
  pr "%s WARNING: THIS FILE IS GENERATED FROM\n" c;
  pr "%s %s\n" c (String.concat " " inputs);
  pr "%s ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.\n" c;
  pr "%s\n" c;
  pr "%s Copyright (C) 2013-2019 Red Hat Inc.\n" c;
  pr "%s\n" c;
  pr "%s This library is free software; you can redistribute it and/or\n" c;
  pr "%s modify it under the terms of the GNU Lesser General Public\n" c;
  pr "%s License as published by the Free Software Foundation; either\n" c;
  pr "%s version 2 of the License, or (at your option) any later version.\n" c;
  pr "%s\n" c;
  pr "%s This library is distributed in the hope that it will be useful,\n" c;
  pr "%s but WITHOUT ANY WARRANTY; without even the implied warranty of\n" c;
  pr "%s MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n" c;
  pr "%s Lesser General Public License for more details.\n" c;
  pr "%s\n" c;
  pr "%s You should have received a copy of the GNU Lesser General Public\n" c;
  pr "%s License along with this library; if not, write to the Free Software\n" c;
  pr "%s Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n" c;
  (match comment_style with
   | CStyle -> pr " */\n"
   | CPlusPlusStyle
   | HashStyle -> ()
   | OCamlStyle -> pr " *)\n"
   | HaskellStyle -> pr "-}\n"
   | PODCommentStyle -> pr "\n=end comment\n"
  );
  pr "\n"

let files_equal n1 n2 =
  let cmd = sprintf "cmp -s %s %s" (Filename.quote n1) (Filename.quote n2) in
  match Sys.command cmd with
  | 0 -> true
  | 1 -> false
  | i -> failwithf "%s: failed with error code %d" cmd i

let output_to filename k =
  let filename_new = filename ^ ".new" in
  chan := open_out filename_new;
  k ();
  close_out !chan;
  chan := Pervasives.stdout;

  (* Is the new file different from the current file? *)
  if Sys.file_exists filename && files_equal filename filename_new then
    unlink filename_new                 (* same, so skip it *)
  else (
    (* different, overwrite old one *)
    (try chmod filename 0o644 with Unix_error _ -> ());
    rename filename_new filename;
    chmod filename 0o444;
    printf "written %s\n%!" filename;
  )

let string_of_location (file, lineno) = sprintf "%s:%d" file lineno
let line_directive_of_location (file, lineno) =
  sprintf "#line %d \"%s\"" lineno file

(*----------------------------------------------------------------------*)

(* Implement state machine. *)

let all_external_events =
  [NotifyRead; NotifyWrite;
   CmdCreate; CmdConnectSockAddr; CmdConnectTCP; CmdConnectCommand; CmdIssue]

let string_of_external_event = function
  | NotifyRead -> "NotifyRead"
  | NotifyWrite -> "NotifyWrite"
  | CmdCreate -> "CmdCreate"
  | CmdConnectSockAddr -> "CmdConnectSockAddr"
  | CmdConnectTCP -> "CmdConnectTCP"
  | CmdConnectCommand -> "CmdConnectCommand"
  | CmdIssue -> "CmdIssue"

let c_string_of_external_event = function
  | NotifyRead -> "notify_read"
  | NotifyWrite -> "notify_write"
  | CmdCreate -> "cmd_create"
  | CmdConnectSockAddr -> "cmd_connect_sockaddr"
  | CmdConnectTCP -> "cmd_connect_tcp"
  | CmdConnectCommand -> "cmd_connect_command"
  | CmdIssue -> "cmd_issue"

(* Find a state in the state machine hierarchy by path.  The [path]
 * parameter is a list like [["READY"]] or [["MAGIC"; "START"]].
 *)
let find_state path =
  let rec find sm = function
    | [] -> raise Not_found
    | [n] ->
       (* Find a state leaf node. *)
       let rec loop = function
         | [] -> raise Not_found
         | State ({ name } as ret) :: _ when n = name -> ret
         | _ :: rest -> loop rest
       in
       loop sm
    | g :: path ->
       (* Find a state machine group. *)
       let rec loop = function
         | [] -> raise Not_found
         | Group (name, group) :: _ when g = name -> find group path
         | _ :: rest -> loop rest
       in
       loop sm
  in
  try (find state_machine path : state)
  with Not_found ->
       failwithf "find_state: ‘%s’ not found" (String.concat "." path)

let dot_rex = Str.regexp "\\."

(* Resolve a stringified path to a state.
 *
 * [prefix] parameter is the current prefix.  We resolve paths
 * relative to this.
 *
 * Stringified paths can be:
 * ["STATE"] => state relative to current level
 * ["GROUP.STATE"] => state below group at current level (to any depth)
 * [".TOP"] => state at the top level
 * ["^UP"] => state at a level above this one
 *)
let rec resolve_state prefix str =
  let len = String.length str in
  if len >= 1 && String.sub str 0 1 = "." then
    resolve_state [] (String.sub str 1 (len-1))
  else if len >= 1 && String.sub str 0 1 = "^" then (
    let parent =
      match List.rev prefix with
      | [] -> failwithf "resolve_state: %s (^) used from top level group" str
      | _ :: rest -> List.rev rest in
    resolve_state parent (String.sub str 1 (len-1))
  )
  else (
    let path = Str.split_delim dot_rex str in
    find_state (prefix @ path)
  )

(* Flatten the state machine hierarchy.  This sets the [parsed.prefix],
 * [parsed.state_enum], [parsed.events] fields in the state.
 *)
let states : state list =
  let rec flatten prefix = function
    | [] -> []
    | State st :: rest ->
       st.parsed <-
         { st.parsed with
           prefix = prefix;
           display_name = (
             match prefix with
             | [] -> st.name
             | prefix -> String.concat "." prefix ^ "." ^ st.name
           );
           state_enum = (
             let path = String.concat "" (List.map ((^) "_") prefix) in
             "STATE" ^ path ^ "_" ^ st.name
           );
           events = (
             List.map (
               fun (ev, str) ->
                 (* In external_events,
                  * special string [""] means current state.
                  *)
                 if str = "" then ev, st
                 else ev, resolve_state prefix str
             ) st.external_events
           )
         };
       st :: flatten prefix rest
    | Group (name, group) :: rest ->
       let states = flatten (prefix @ [name]) group in
       states @ flatten prefix rest
  in
  flatten [] state_machine

(* Read and parse the state machine C code. *)
let state_machine_prologue =
  let parse_states_file filename =
    let chan = open_in filename in
    let lines = ref [] in
    let lineno = ref 1 in
    (try while true do
           let line = input_line chan in
           let loc : location = filename, !lineno in
           incr lineno;
           lines := (loc, line) :: !lines
         done
     with End_of_file -> ());
    close_in chan;
    (* Note this list is initially in reverse order. *)
    let lines = !lines in

    (* The last line in the file must have a particular form, check
     * and remove.
     *)
    if List.length lines = 0 ||
         snd (List.hd lines) <> "} /* END STATE MACHINE */" then
      failwithf "%s: unexpected file ending" filename;
    let lines = List.tl lines in
    let lines = List.rev lines in

    (* Find the start of the state machine and split the list into
     * the prologue and the list of state code fragments.
     *)
    let rec loop acc = function
      | [] -> failwithf "%s: could not find state machine" filename
      | (_, "/* STATE MACHINE */ {") :: lines -> ((filename, 1), acc), lines
      | (_, line) :: lines -> loop (acc ^ line ^ "\n") lines
    in
    let prologue, lines = loop "" lines in

    let statecodes = ref [] in
    let curr_state = ref None in
    let rex = Str.regexp "^ \\([A-Z0-9][A-Z0-9_\\.]*\\):$" in
    List.iter (
      fun (loc, line) ->
        if Str.string_match rex line 0 then ( (* new case *)
          (match !curr_state with
           | None -> ()
           | Some state -> statecodes := state :: !statecodes);
          curr_state := Some (Str.matched_group 1 line, "", loc);
        )
        else (
          (match !curr_state with
           | None ->
              failwithf "%s: missing label" (string_of_location loc)
           | Some (name, code, loc) ->
              curr_state := Some (name, code ^ "\n" ^ line, loc)
          )
        );
      ) lines;
    (match !curr_state with
     | None -> ()
     | Some state -> statecodes := state :: !statecodes);
    let statecodes = List.rev !statecodes in

    prologue, statecodes
  in

  (* Read all the input files, called [generator/states*.c] *)
  let files = List.sort compare (Array.to_list (Sys.readdir "generator")) in
  let files = List.filter (
    fun filename ->
      let len = String.length filename in
      len >= 8 && String.sub filename 0 6 = "states" &&
        String.sub filename (len-2) 2 = ".c"
  ) files in
  let files = List.map ((^) "generator/") files in
  let files = List.map parse_states_file files in

  (* Mash together the prologues and the state codes. *)
  let prologue =
    String.concat "" (
      List.map (
        fun ((loc, prologue), _) ->
          line_directive_of_location loc ^ "\n" ^ prologue ^ "\n"
       ) files
     ) in
  let statecodes = List.concat (List.map snd files) in

  (* Resolve the state names in the code to paths. *)
  let statecodes =
    List.map (
      fun (name, code, loc) ->
        let path = Str.split_delim dot_rex name in
        let state = find_state path in
        state, code, loc
    ) statecodes in

  (* Parse the state code fragments to get internal state
   * transitions, marked by "%STATE".
   *)
  let rex = Str.regexp "%\\([\\^\\.]*[A-Z0-9][A-Z0-9_\\.]*\\)" in
  List.iter (
    fun (state, code, loc) ->
      let code = Str.full_split rex code in
      let code =
        List.map (
          function
          | Str.Delim str ->
             Str.Delim (String.sub str 1 (String.length str - 1))
          | (Str.Text _) as c -> c
      ) code in

      (* Create the list of internal transitions. *)
      state.parsed <-
        { state.parsed with
          internal_transitions = (
            filter_map (
              function
              | Str.Delim str ->
                 let next_state = resolve_state state.parsed.prefix str in
                 Some next_state
              | Str.Text _ -> None
            ) code
        )
        };

      (* Create the final C code fragment. *)
      state.parsed <-
        { state.parsed with
          loc = loc;
          code =
            String.concat "" (
              List.map (
                function
                | Str.Delim str ->
                   let next_state = resolve_state state.parsed.prefix str in
                   next_state.parsed.state_enum
                | Str.Text text -> text
                ) code
            )
        }
  ) statecodes;

  prologue

(* Verify state transitions are permitted. *)
let () =
  let verify_state_transition from_state to_state =
    let from_prefix = from_state.parsed.prefix
    and to_prefix = to_state.parsed.prefix in
    (* Going from state to state within the same group is always allowed. *)
    if from_prefix = to_prefix then
      ()
    (* Going upwards to any state is always allowed. *)
    else if List.length from_prefix > List.length to_prefix then
      ()
    (* When going downwards (even into an adjacent tree) you must
     * always enter a group at the START state.
     *)
    else if to_state.name <> "START" then (
      failwithf "non-permitted state transition: %s.%s -> %s.%s"
                (String.concat "." from_prefix) from_state.name
                (String.concat "." to_prefix) to_state.name
    )
  in
  List.iter (
    fun ({ parsed = { internal_transitions; events } } as state) ->
      List.iter (verify_state_transition state) internal_transitions;
      List.iter (fun (_, next_state) -> verify_state_transition state next_state) events
  ) states

(* Write the state machine code. *)
let generate_lib_states_h () =
  generate_header ~extra_sources:["generator/states*.c"] CStyle;
  pr "enum state {\n";
  List.iter (
    fun ({ comment; parsed = { display_name; state_enum } }) ->
      pr "  /* %s: %s */\n" display_name comment;
      pr "  %s,\n" state_enum;
      pr "\n";
  ) states;
  pr "};\n";
  pr "\n";
  pr "/* These correspond to the external events in generator/generator. */\n";
  pr "enum external_event {\n";
  List.iter (
    fun e -> pr "  %s,\n" (c_string_of_external_event e)
  ) all_external_events;
  pr "};\n";
  pr "\n";
  pr "/* State groups. */\n";
  pr "enum state_group {\n";
  pr "  GROUP_TOP,\n";
  let rec loop prefix = function
    | [] -> ()
    | State _ :: rest ->
       loop prefix rest
    | Group (name, group) :: rest ->
       let enum =
         "GROUP" ^ String.concat "" (List.map ((^) "_") prefix) ^ "_" ^ name in
       pr "  %s,\n" enum;
       loop (prefix @ [name]) group;
       loop prefix rest
  in
  loop [] state_machine;
  pr "};\n"

let generate_lib_states_c () =
  generate_header ~extra_sources:["generator/states*.c"] CStyle;

  pr "%s\n" state_machine_prologue;
  pr "\n";
  pr "#define SET_NEXT_STATE(s) (*blocked = false, *next_state = (s))\n";
  pr "\n";

  (* The state machine C code fragments. *)
  List.iter (
    fun ({ comment; parsed = { display_name; state_enum; loc; code } }) ->
      pr "/* %s: %s */\n" display_name comment;
      pr "static int\n";
      pr "_enter_%s (struct nbd_handle *h,\n" state_enum;
      pr "             struct nbd_connection *conn,\n";
      pr "             enum state *next_state,\n";
      pr "             bool *blocked)\n";
      pr "{\n";
      if code <> "" then (
        pr "%s\n" (line_directive_of_location loc);
        pr "%s\n" code
      )
      else
        pr "  return 0;\n";
      pr "}\n";
      pr "\n";
      pr "static int\n";
      pr "enter_%s (struct nbd_handle *h, struct nbd_connection *conn,\n"
         state_enum;
      pr "            bool *blocked)\n";
      pr "{\n";
      pr "  int r;\n";
      pr "  enum state next_state = %s;\n" state_enum;
      pr "\n";
      pr "  r = _enter_%s (h, conn, &next_state, blocked);\n" state_enum;
      pr "  if (conn->state != next_state) {\n";
      pr "    debug (h, \"conn %%\" PRIi64 \": transition: %%s -> %%s\",\n";
      pr "           conn->id, \"%s\",\n" display_name;
      pr "           nbd_internal_state_short_string (next_state));\n";
      pr "    conn->state = next_state;\n";
      pr "  }\n";
      pr "  return r;\n";
      pr "}\n";
      pr "\n";
  ) states;

  pr "/* Run the state machine based on an external event until it would block. */\n";
  pr "int\n";
  pr "nbd_internal_run (struct nbd_handle *h, struct nbd_connection *conn,\n";
  pr "                  enum external_event ev)\n";
  pr "{\n";
  pr "  int r;\n";
  pr "  bool blocked;\n";
  pr "\n";
  pr "  /* Validate and handle the external event. */\n";
  pr "  switch (conn->state)\n";
  pr "  {\n";
  List.iter (
    fun ({ parsed = { display_name; state_enum; events } } as state) ->
      pr "  case %s:\n" state_enum;
      if events <> [] then (
        pr "    switch (ev)\n";
        pr "    {\n";
        List.iter (
          fun (e, next_state) ->
            pr "    case %s:\n" (c_string_of_external_event e);
            if state != next_state then (
              pr "      conn->state = %s;\n" next_state.parsed.state_enum;
              pr "      debug (h, \"conn %%\" PRIi64 \": event %%s: %%s -> %%s\",\n";
              pr "             conn->id, \"%s\", \"%s\", \"%s\");\n"
                 (string_of_external_event e)
                 display_name next_state.parsed.display_name;
            );
            pr "      goto ok;\n";
        ) events;
        pr "    default: ; /* nothing, silence GCC warning */\n";
        pr "    }\n";
      );
      pr "    break;\n";
  ) states;
  pr "  }\n";
  pr "\n";
  pr "  set_error (0, \"external event %%d is invalid in state %%s\",\n";
  pr "             ev, nbd_internal_state_short_string (conn->state));\n";
  pr "  return -1;\n";
  pr "\n";
  pr " ok:\n";
  pr "  do {\n";
  pr "    blocked = true;\n";
  pr "\n";
  pr "    /* Run a single step. */\n";
  pr "    switch (conn->state)\n";
  pr "    {\n";
  List.iter (
    fun { parsed = { state_enum } } ->
      pr "    case %s:\n" state_enum;
      pr "      r = enter_%s (h, conn, &blocked);\n" state_enum;
      pr "      break;\n"
  ) states;
  pr "    default:\n";
  pr "      abort (); /* Should never happen, but keeps GCC happy. */\n";
  pr "    }\n";
  pr "\n";
  pr "    if (r == -1) return -1;\n";
  pr "  } while (!blocked);\n";
  pr "  return 0;\n";
  pr "}\n";
  pr "\n";

  pr "/* Returns whether in the current state read or write would be valid. */\n";
  pr "int\n";
  pr "nbd_unlocked_aio_get_direction (struct nbd_connection *conn)\n";
  pr "{\n";
  pr "  int r = 0;\n";
  pr "\n";
  pr "  switch (conn->state)\n";
  pr "  {\n";
  List.iter (
    fun ({ parsed = { state_enum; events } }) ->
      pr "  case %s:\n" state_enum;
      List.iter (
        fun (e, _) ->
          match e with
          | NotifyRead ->  pr "    r |= LIBNBD_AIO_DIRECTION_READ;\n"
          | NotifyWrite -> pr "    r |= LIBNBD_AIO_DIRECTION_WRITE;\n"
          | CmdCreate | CmdConnectSockAddr | CmdConnectTCP | CmdConnectCommand
          | CmdIssue -> ()
      ) events;
      pr "    break;\n";
  ) states;
  pr "  }\n";
  pr "\n";
  pr "  return r;\n";
  pr "}\n";
  pr "\n";

  pr "/* Other functions associated with the state machine. */\n";
  pr "const char *\n";
  pr "nbd_internal_state_short_string (enum state state)\n";
  pr "{\n";
  pr "  switch (state)\n";
  pr "  {\n";
  List.iter (
    fun ({ parsed = { display_name; state_enum } }) ->
      pr "  case %s:\n" state_enum;
      pr "    return \"%s\";\n" display_name
  ) states;
  pr "  }\n";
  pr "\n";
  pr "  /* This function is only used for debug messages, and\n";
  pr "   * this should never happen.\n";
  pr "   */\n";
  pr "  return \"UNKNOWN!\";\n";
  pr "}\n";
  pr "\n";

  pr "const char *\n";
  pr "nbd_unlocked_connection_state (struct nbd_connection *conn)\n";
  pr "{\n";
  pr "  switch (conn->state)\n";
  pr "  {\n";
  List.iter (
    fun ({ comment; parsed = { display_name; state_enum } }) ->
      pr "  case %s:\n" state_enum;
      pr "    return \"%s\" \": \"\n" display_name;
      pr "           \"%s\";\n" comment;
      pr "\n";
  ) states;
  pr "  }\n";
  pr "\n";
  pr "  return NULL;\n";
  pr "}\n";
  pr "\n";

  pr "/* Map a state to its group name. */\n";
  pr "enum state_group\n";
  pr "nbd_internal_state_group (enum state state)\n";
  pr "{\n";
  pr "  switch (state) {\n";
  List.iter (
    fun ({ parsed = { prefix; state_enum } }) ->
      pr "  case %s:\n" state_enum;
      if prefix = [] then
        pr "    return GROUP_TOP;\n"
      else
        pr "    return GROUP%s;\n"
           (String.concat "" (List.map ((^) "_") prefix))
  ) states;
  pr "  default:\n";
  pr "    abort (); /* Should never happen, but keeps GCC happy. */\n";
  pr "  }\n";
  pr "}\n";
  pr "\n";

  pr "/* Map a state group to its parent group. */\n";
  pr "enum state_group\n";
  pr "nbd_internal_state_group_parent (enum state_group group)\n";
  pr "{\n";
  pr "  switch (group) {\n";
  pr "  case GROUP_TOP:\n";
  pr "    return GROUP_TOP;\n";
  let rec loop prefix = function
    | [] -> ()
    | State _ :: rest ->
       loop prefix rest
    | Group (name, group) :: rest ->
       let enum =
         "GROUP" ^ String.concat "" (List.map ((^) "_") prefix) ^ "_" ^ name in
       pr "  case %s:\n" enum;
       if prefix = [] then
         pr "    return GROUP_TOP;\n"
       else (
         let parent = "GROUP" ^ String.concat "" (List.map ((^) "_") prefix) in
         pr "    return %s;\n" parent
       );
       loop (prefix @ [name]) group;
       loop prefix rest
  in
  loop [] state_machine;
  pr "  default:\n";
  pr "    abort (); /* Should never happen, but keeps GCC happy. */\n";
  pr "  }\n";
  pr "};\n"



(*----------------------------------------------------------------------*)

(* Generate C API. *)

let generate_lib_libnbd_syms () =
  generate_header HashStyle;

  pr "{\n";
  pr "  global:\n";
  pr "    nbd_create;\n";
  pr "    nbd_close;\n";
  pr "    nbd_get_connection;\n";
  pr "    nbd_get_errno;\n";
  pr "    nbd_get_error;\n";
  pr "    nbd_connection_close;\n";
  List.iter (fun (name, _) -> pr "    nbd_%s;\n" name) handle_calls;
  List.iter (fun (name, _) -> pr "    nbd_%s;\n" name) connection_calls;
  pr "\n";
  pr "  # Everything else is hidden.\n";
  pr "  local: *;\n";
  pr "};\n"

let rec name_of_arg = function
| ArrayAndLen (arg, n) -> name_of_arg arg @ [n]
| Bool n -> [n]
| BytesIn (n, len) -> [n; len]
| BytesOut (n, len) -> [n; len]
| Callback (n, _) -> [n]
| Int n -> [n]
| Int64 n -> [n]
| Opaque n -> [n]
| Path n -> [n]
| SockAddrAndLen (n, len) -> [n; len]
| String n -> [n]
| StringList n -> [n]
| UInt n -> [n]
| UInt32 n -> [n]
| UInt64 n -> [n]

let rec print_c_arg_list ?handle args =
  pr "(";
  let comma = ref false in
  (match handle with
   | None -> ()
   | Some (htype, hname) ->
      comma := true;
      pr "struct nbd_%s *" htype;
      match hname with
      | None -> ()
      | Some hname -> pr "%s" hname
  );
  List.iter (
    fun arg ->
      if !comma then pr ", ";
      comma := true;
      match arg with
      | ArrayAndLen (UInt32 n, len) -> pr "uint32_t *%s, size_t %s" n len
      | ArrayAndLen _ -> assert false
      | Bool n -> pr "bool %s" n
      | BytesIn (n, len) -> pr "const void *%s, size_t %s" n len
      | BytesOut (n, len) -> pr "void *%s, size_t %s" n len
      | Callback (n, args) -> pr "void (*%s) " n; print_c_arg_list args
      | Int n -> pr "int %s" n
      | Int64 n -> pr "int64_t %s" n
      | Opaque n -> pr "void *%s" n
      | Path n
      | String n -> pr "const char *%s" n
      | StringList n -> pr "char **%s" n
      | SockAddrAndLen (n, len) ->
         pr "const struct sockaddr *%s, socklen_t %s" n len
      | UInt n -> pr "unsigned %s" n
      | UInt32 n -> pr "uint32_t %s" n
      | UInt64 n -> pr "uint64_t %s" n
  ) args;
  pr ")"

let print_call name htype args ret =
  (match ret with
   | RBool
   | RErr
   | RFd
   | RInt -> pr "int "
   | RConstString -> pr "const char *"
   | RInt64 -> pr "int64_t "
   | RString -> pr "char *"
  );
  pr "nbd_%s " name;
  print_c_arg_list ~handle:(htype, None) args

let print_extern name htype args ret =
  pr "extern ";
  print_call name htype args ret;
  pr ";\n"

let generate_include_libnbd_h () =
  generate_header CStyle;

  pr "#ifndef LIBNBD_H\n";
  pr "#define LIBNBD_H\n";
  pr "\n";
  pr "#include <stdbool.h>\n";
  pr "#include <stdint.h>\n";
  pr "#include <sys/socket.h>\n";
  pr "\n";
  pr "struct nbd_handle;\n";
  pr "struct nbd_connection;\n";
  pr "\n";
  pr "#define LIBNBD_AIO_DIRECTION_READ  1\n";
  pr "#define LIBNBD_AIO_DIRECTION_WRITE 2\n";
  pr "#define LIBNBD_AIO_DIRECTION_BOTH  3\n";
  pr "\n";
  pr "#define LIBNBD_CMD_FLAG_FUA        (1<<0)\n";
  pr "#define LIBNBD_CMD_FLAG_REQ_ONE    (1<<3)\n";
  pr "\n";
  pr "extern struct nbd_handle *nbd_create (void);\n";
  pr "extern void nbd_close (struct nbd_handle *h);\n";
  pr "extern const char *nbd_get_error (void);\n";
  pr "extern int nbd_get_errno (void);\n";
  pr "\n";
  List.iter (
    fun (name, { args; ret }) -> print_extern name "handle" args ret
  ) handle_calls;
  pr "\n";
  pr "extern struct nbd_connection *nbd_get_connection (struct nbd_handle *h,\n";
  pr "                                                  unsigned i);\n";
  pr "extern int nbd_connection_close (struct nbd_connection *conn);\n";
  pr "\n";
  List.iter (
    fun (name, { args; ret }) -> print_extern name "connection" args ret
  ) connection_calls;
  pr "\n";
  pr "#endif /* LIBNBD_H */\n"

let generate_lib_unlocked_h () =
  generate_header CStyle;

  pr "#ifndef LIBNBD_UNLOCKED_H\n";
  pr "#define LIBNBD_UNLOCKED_H\n";
  pr "\n";
  List.iter (
    fun (name, { args; ret }) ->
      print_extern ("unlocked_" ^ name) "handle" args ret
  ) handle_calls;
  pr "\n";
  List.iter (
    fun (name, { args; ret }) ->
      print_extern ("unlocked_" ^ name) "connection" args ret
  ) connection_calls;
  pr "\n";
  pr "#endif /* LIBNBD_UNLOCKED_H */\n"

(* Generate wrappers around each API call which are a place to
 * grab the thread mutex (lock) and do logging.
 *)
let generate_lib_api_c () =
  let print_wrapper name htype hname lock args ret =
    (match ret with
     | RBool
     | RErr
     | RFd
     | RInt -> pr "int\n"
     | RConstString -> pr "const char *\n"
     | RInt64 -> pr "int64_t\n"
     | RString -> pr "char *\n"
    );
    pr "nbd_%s " name;
    print_c_arg_list ~handle:(htype, Some hname) args;
    pr "\n";
    pr "{\n";
    (match ret with
     | RBool
     | RErr
     | RFd
     | RInt -> pr "  int ret;\n"
     | RConstString -> pr "  const char *ret;\n"
     | RInt64 -> pr "  int64_t ret;\n"
     | RString -> pr "  char *ret;\n"
    );
    pr "\n";
    pr "  pthread_mutex_lock (&%s);\n" lock;
    pr "  nbd_internal_reset_error (\"nbd_%s\");\n" name;
    pr "  ret = nbd_unlocked_%s (%s" name hname;
    let argnames = List.flatten (List.map name_of_arg args) in
    List.iter (pr ", %s") argnames;
    pr ");\n";
    pr "  pthread_mutex_unlock (&%s);\n" lock;
    pr "  return ret;\n";
    pr "}\n";
    pr "\n";
  in

  generate_header CStyle;

  pr "#include <config.h>\n";
  pr "\n";
  pr "#include <stdio.h>\n";
  pr "#include <stdlib.h>\n";
  pr "\n";
  pr "#include <pthread.h>\n";
  pr "\n";
  pr "#include \"libnbd.h\"\n";
  pr "#include \"internal.h\"\n";
  pr "\n";
  List.iter (
    fun (name, { args; ret }) ->
      print_wrapper name "handle" "h" "h->lock" args ret
  ) handle_calls;
  pr "\n";
  List.iter (
    fun (name, { args; ret }) ->
      print_wrapper name "connection" "conn" "conn->h->lock" args ret
  ) connection_calls

let print_api htype (name, { args; ret; shortdesc; longdesc }) =
  pr "=head2 %s —\n" name;
  pr "%s\n" shortdesc;
  pr "\n";
  pr " ";
  print_call name htype args ret;
  pr "\n";
  pr "\n";
  pr "%s\n" longdesc;
  pr "\n";
  let errcode =
    match ret with
    | RBool ->
       pr "This call returns a boolean value.\n";
       "-1"
   | RConstString ->
       pr "This call returns a statically allocated string.\n";
       "NULL"
   | RErr ->
       pr "If the call is successful the function returns C<0>.\n";
       "-1"
   | RFd ->
       pr "This call returns a file descriptor.\n";
       "-1"
   | RInt ->
       pr "This call returns an integer E<ge> 0.\n";
       "-1"
   | RInt64 ->
       pr "This call returns a 64 bit signed integer E<ge> 0.\n";
       "-1"
   | RString ->
       pr "This call returns a string.  The caller must free the\n";
       pr "returned string to avoid a memory leak.\n";
       "NULL"
  in
  pr "\n";
  pr "On error C<%s> is returned.\n" errcode;
  pr "See L<libnbd(3)/ERROR HANDLING> for how to get further details\n";
  pr "of the error.\n";
  pr "\n"

let generate_docs_libnbd_api_pod () =
  pr "
=head1 NAME

libnbd-api - libnbd C API

=head1 SYNOPSIS

 #include <libnbd.h>
 
 struct nbd_handle *nbd;
 char buf[512];
 
 if ((nbd = nbd_create ()) == NULL ||
     nbd_connect_tcp (nbd, \"server.example.com\", \"nbd\") == -1 ||
     nbd_pread (nbd, buf, sizeof buf, 0) == -1)
   fprintf (stderr, \"%%s\n\", nbd_get_error ());
   exit (EXIT_FAILURE);
 }
 nbd_close (nbd);

 cc prog.c -o prog -lnbd
or:
 cc prog.c -o prog `pkg-config libnbd --cflags --libs`

=head1 DESCRIPTION

This manual page describes all of the libnbd API calls from C
in detail.  If you want an overview of using the API, or to see
how to call the API from other programming languages, start
with libnbd(3).

=head1 CREATE, GET AND CLOSE HANDLES

 struct nbd_handle *nbd;

This opaque structure describes an NBD client handle.  It may
contain one or more connections to the NBD server.

 struct nbd_connection *conn;

This opaque structure describes an NBD connection to a server
(eg. over a Unix domain socket or TCP port).  There is usually
one of these in a handle, but there may be more if “multi-conn”
has been enabled on the handle.

 struct nbd_handle *nbd_create (void);

Create a new handle.  Returns a pointer to the opaque handle
structure.

On error this returns C<NULL>.  See L<libnbd(3)/ERROR HANDLING>
for how to get further details of the error.

 void nbd_close (struct nbd_handle *nbd);

Closing all the handle, and also closes down all connections to
the server belonging to this handle, and frees any associated
resources.

 struct nbd_connection *nbd_get_connection (struct nbd_handle *nbd,
                                            unsigned i);

Get the I<i'th> connection structure managed by this handle.
Most handles have one connection (use C<i = 0>).  If you have
enabled ”multi-conn” then more than one connection can be
returned here.

On error this returns C<NULL>.  See L<libnbd(3)/ERROR HANDLING>
for how to get further details of the error.

 int nbd_connection_close (struct nbd_connection *conn);

Close and reopen the connection.  This closes the connection
object and frees all resources associated with it.  Then it
creates a new connection object in the slot in the handle
which was previously occupied by this connection.  Note you
don't normally have to call this because closing the whole
handle will also close and free up all connections owned by
the handle.

On error this returns C<-1>.  See L<libnbd(3)/ERROR HANDLING>
for how to get further details of the error.

=head1 GETTING THE LATEST ERROR MESSAGE IN THE THREAD

See L<libnbd(3)/ERROR HANDLING> for more discussion of how
error handling works in libnbd.

 const char *nbd_get_error (void);

Return the most recent error message in the current thread.
The error message is only valid if called immediately after
the failing call, from the same thread.  The error string
returned will be freed up next time any libnbd API is called
from the same thread, so if you need to keep it you must make
a copy.

This should never return C<NULL> provided there was an error
returned from the immediately preceding libnbd call in the
current thread.

 int nbd_get_errno (void);

Return the most recent C<errno> in the current thread.  Not all
errors have corresponding errnos, so even if there has been an error
this may return C<0>.  Error codes are the standard ones from
C<E<lt>errno.hE<gt>>.

";

  pr "=head1 HANDLE CALLS\n";
  pr "\n";
  pr "These are calls where the first parameter is always\n";
  pr "C<struct nbd_handle *>.\n";
  pr "\n";

  List.iter (print_api "handle") handle_calls;

  pr "=head1 CONNECTION CALLS\n";
  pr "\n";
  pr "These are calls where the first parameter is always\n";
  pr "C<struct nbd_connection *>.\n";
  pr "\n";

  List.iter (print_api "connection") connection_calls;

  pr "\
=head1 SEE ALSO

L<libnbd(3)>.

=head1 AUTHORS

Eric Blake

Richard W.M. Jones

=head1 COPYRIGHT

Copyright (C) 2019 Red Hat Inc.
"

(*----------------------------------------------------------------------*)

(* Python bindings. *)

let generate_python_methods_h () =
  generate_header CStyle;

  pr "#ifndef LIBNBD_METHODS_H\n";
  pr "#define LIBNBD_METHODS_H\n";
  pr "\n";
  pr "#define PY_SSIZE_T_CLEAN 1\n";
  pr "#include <Python.h>\n";
  pr "\n";
  pr "#include <assert.h>\n";
  pr "\n";
  pr "\
extern char **nbd_internal_py_get_string_list (PyObject *);
extern void nbd_internal_py_free_string_list (char **);

static inline struct nbd_handle *
get_handle (PyObject *obj)
{
  assert (obj);
  assert (obj != Py_None);
  return (struct nbd_handle *) PyCapsule_GetPointer(obj, \"nbd_handle\");
}

static inline struct nbd_connection *
get_connection (PyObject *obj)
{
  assert (obj);
  assert (obj != Py_None);
  return (struct nbd_connection *) PyCapsule_GetPointer(obj, \"nbd_connection\");
}
";

  List.iter (
    fun name ->
      pr "extern PyObject *nbd_internal_py_%s (PyObject *self, PyObject *args);\n"
         name;
  ) ([ "create"; "close"; "get_connection"; "connection_close" ] @
       List.map fst (handle_calls @ connection_calls));

  pr "\n";
  pr "#endif /* LIBNBD_METHODS_H */\n"

let generate_python_libnbdmod_c () =
  generate_header CStyle;

  pr "#include <config.h>\n";
  pr "\n";
  pr "#define PY_SSIZE_T_CLEAN 1\n";
  pr "#include <Python.h>\n";
  pr "\n";
  pr "#include <stdio.h>\n";
  pr "#include <stdlib.h>\n";
  pr "#include <assert.h>\n";
  pr "\n";
  pr "#include <libnbd.h>\n";
  pr "\n";
  pr "#include \"methods.h\"\n";
  pr "\n";
  pr "static PyMethodDef methods[] = {\n";
  List.iter (
    fun name ->
      pr "  { (char *) \"%s\", nbd_internal_py_%s, METH_VARARGS, NULL },\n"
         name name;
  ) ([ "create"; "close"; "get_connection"; "connection_close" ] @
       List.map fst (handle_calls @ connection_calls));
  pr "  { NULL, NULL, 0, NULL }\n";
  pr "};\n";
  pr "\n";
  pr "\
static struct PyModuleDef moduledef = {
  PyModuleDef_HEAD_INIT,
  \"libnbdmod\",           /* m_name */
  \"libnbd module\",       /* m_doc */
  -1,                    /* m_size */
  methods,               /* m_methods */
  NULL,                  /* m_reload */
  NULL,                  /* m_traverse */
  NULL,                  /* m_clear */
  NULL,                  /* m_free */
};

static PyObject *
moduleinit (void)
{
  return PyModule_Create (&moduledef);
}

extern PyMODINIT_FUNC PyInit_libnbdmod (void);

PyMODINIT_FUNC
PyInit_libnbdmod (void)
{
  return moduleinit ();
}
"

let print_python_binding name { args; ret } htype hname =
  pr "PyObject *\n";
  pr "nbd_internal_py_%s (PyObject *self, PyObject *args)\n" name;
  pr "{\n";
  pr "  PyObject *py_%s;\n" hname;
  pr "  struct nbd_%s *%s;\n" htype hname;
  (match ret with
   | RBool
   | RErr
   | RFd
   | RInt -> pr "  int ret;\n"
   | RConstString -> pr "  const char *ret;\n"
   | RInt64 -> pr "  int64_t ret;\n"
   | RString -> pr "  char *ret;\n";
  );
  pr "  PyObject *py_ret;\n";
  List.iter (
    function
    | ArrayAndLen (UInt32 n, len) ->
       pr "  PyObject *py_%s;\n" n;
       pr "  uint32_t *%s;\n" n;
       pr "  size_t %s;\n" len;
    | ArrayAndLen _ -> assert false
    | Bool n -> pr "  int %s;\n" n
    | BytesIn (n, _) -> pr "  Py_buffer %s;\n" n
    | BytesOut (n, count) ->
       pr "  char *%s;\n" n;
       pr "  Py_ssize_t %s;\n" count
    | Callback (n, _) -> pr "  PyObject *%s;\n" n
    | Int n -> pr "  int %s;\n" n
    | Int64 n ->
       pr "  int64_t %s_i64;\n" n;
       pr "  long long %s; /* really int64_t */\n" n
    | Opaque n ->
       pr "  PyObject *%s;\n" n
    | Path n -> pr "  char *%s = NULL;\n" n
    | SockAddrAndLen (n, _) ->
       pr "  /* XXX Complicated - Python uses a tuple of different\n";
       pr "   * lengths for the different socket types.\n";
       pr "   */\n";
       pr "  PyObject *%s;\n" n
    | String n -> pr "  const char *%s;\n" n
    | StringList n ->
       pr "  PyObject *py_%s;\n" n;
       pr "  char **%s = NULL;\n" n
    | UInt n -> pr "  unsigned int %s;\n" n
    | UInt32 n ->
       pr "  uint32_t %s_u32;\n" n;
       pr "  unsigned int %s; /* really uint32_t */\n" n
    | UInt64 n ->
       pr "  uint64_t %s_u64;\n" n;
       pr "  unsigned long long %s; /* really uint64_t */\n" n
  ) args;
  pr "\n";

  (* Parse the Python parameters. *)
  pr "  if (!PyArg_ParseTuple (args, (char *) \"O\"";
  List.iter (
    function
    | ArrayAndLen _ -> pr " \"O\""
    | Bool n -> pr " \"b\""
    | BytesIn (n, _) -> pr " \"y*\""
    | BytesOut (_, count) -> pr " \"n\""
    | Callback (n, _) -> pr " \"O\""
    | Int n -> pr " \"i\""
    | Int64 n -> pr " \"L\""
    | Opaque _ -> pr " \"O\""
    | Path n -> pr " \"O&\""
    | SockAddrAndLen (n, _) -> pr " \"O\""
    | String n -> pr " \"s\""
    | StringList n -> pr " \"O\""
    | UInt n -> pr " \"I\""
    | UInt32 n -> pr " \"I\""
    | UInt64 n -> pr " \"K\""
  ) args;
  pr "\n";
  pr "                         \":nbd_%s\",\n" name;
  pr "                         &py_%s" hname;
  List.iter (
    function
    | ArrayAndLen (UInt32 n, _) -> pr ", &py_%s" n
    | ArrayAndLen _ -> assert false
    | Bool n -> pr ", &%s" n
    | BytesIn (n, _) -> pr ", &%s" n
    | BytesOut (_, count) -> pr ", &%s" count
    | Callback (n, _) -> pr ", &%s" n
    | Int n -> pr ", &%s" n
    | Int64 n -> pr ", &%s" n
    | Opaque n -> pr ", &%s" n
    | Path n -> pr ", PyUnicode_FSConverter, &%s" n
    | SockAddrAndLen (n, _) -> pr ", &%s" n
    | String n -> pr ", &%s" n
    | StringList n -> pr ", &py_%s" n
    | UInt n -> pr ", &%s" n
    | UInt32 n -> pr ", &%s" n
    | UInt64 n -> pr ", &%s" n
  ) args;
  pr "))\n";
  pr "    return NULL;\n";

  (* Call the underlying C function. *)
  pr "  %s = get_%s (py_%s);\n" hname htype hname;
  List.iter (
    function
    | ArrayAndLen (UInt32 n, len) ->
       pr "  if (!PyList_Check (py_%s)) {\n" n;
       pr "    PyErr_SetString (PyExc_TypeError, \"expecting a list\");\n";
       pr "    return NULL;\n";
       pr "  }\n";
       pr "  %s = PyList_Size (py_%s);\n" len n;
       pr "  if (%s == -1) {\n" len;
       pr "    PyErr_SetString (PyExc_RuntimeError, \"PyList_Size failed\");\n";
       pr "    return NULL;\n";
       pr "  }\n";
       pr "  %s = malloc (sizeof (uint32_t) * %s);\n" n len;
       pr "  if (%s == NULL) {\n" n;
       pr "    PyErr_NoMemory ();\n";
       pr "    return NULL;\n";
       pr "  }\n";
       pr "  for (size_t _i = 0; _i < %s; ++_i)\n" len;
       pr "    %s[_i] = PyLong_AsUnsignedLong (PyList_GetItem (%s, _i));\n" n n
    | ArrayAndLen _ -> assert false
    | Bool _ -> ()
    | BytesIn _ ->
       if htype = "connection" then
         (* The AIO pread/pwrite calls require a buffer which
          * persists for as long as the command is running, which
          * is at least after this function returns.  So we need
          * a way to allocate one of those and pass it to the
          * function from Python and free it later.
          *)
         pr "  abort (); /* XXX BytesIn not implemented for AIO */\n"
    | BytesOut (n, count) ->
       if htype = "connection" then
         pr "  abort (); /* XXX BytesOut not implemented for AIO */\n"
       else
         pr "  %s = malloc (%s);\n" n count
    | Callback _ ->
       pr "  abort (); /* XXX Callback not implemented */\n";
    | Int _ -> ()
    | Int64 n -> pr "  %s_i64 = %s;\n" n n
    | Opaque _ -> ()
    | Path _ -> ()
    | SockAddrAndLen _ ->
       pr "  abort (); /* XXX SockAddrAndLen not implemented */\n";
    | String _ -> ()
    | StringList n ->
       pr "  %s = nbd_internal_py_get_string_list (py_%s);\n" n n;
       pr "  if (!%s) { py_ret = NULL; goto out; }\n" n
    | UInt _ -> ()
    | UInt32 n -> pr "  %s_u32 = %s;\n" n n
    | UInt64 n -> pr "  %s_u64 = %s;\n" n n
  ) args;
  pr "  ret = nbd_%s (%s" name hname;
  List.iter (
    function
    | ArrayAndLen (UInt32 n, len) -> pr ", %s, %s" n len
    | ArrayAndLen _ -> assert false
    | Bool n -> pr ", %s" n
    | BytesIn (n, _) -> pr ", %s.buf, %s.len" n n
    | BytesOut (n, count) -> pr ", %s, %s" n count
    | Callback (n, _) -> pr ", /* XXX */ (void *) %s" n
    | Int n -> pr ", %s" n
    | Int64 n -> pr ", %s_i64" n
    | Opaque n -> pr ", %s" n
    | Path n -> pr ", %s" n
    | SockAddrAndLen (n, _) -> pr ", /* XXX */ (void *) %s, 0" n
    | String n -> pr ", %s" n
    | StringList n -> pr ", %s" n
    | UInt n -> pr ", %s" n
    | UInt32 n -> pr ", %s_u32" n
    | UInt64 n -> pr ", %s_u64" n
  ) args;
  pr ");\n";
  (match ret with
   | RBool | RErr | RFd | RInt | RInt64 -> pr "  if (ret == -1) {\n";
   | RConstString | RString -> pr "  if (ret == NULL) {\n";
  );
  pr "    PyErr_SetString (PyExc_RuntimeError, nbd_get_error ());\n";
  pr "    py_ret = NULL;\n";
  pr "    goto out;\n";
  pr "  }\n";

  (* Convert the result back to a Python object and return it. *)
  let use_ret = ref true in
  List.iter (
    function
    | BytesOut (n, count) ->
       pr "  py_ret = PyBytes_FromStringAndSize (%s, %s);\n" n count;
       use_ret := false
    | ArrayAndLen _
    | Bool _
    | BytesIn _
    | Callback _
    | Int _
    | Int64 _
    | Opaque _
    | Path _
    | SockAddrAndLen _
    | String _
    | StringList _
    | UInt _
    | UInt32 _
    | UInt64 _ -> ()
  ) args;
  if !use_ret then (
    match ret with
    | RBool ->
       pr "  py_ret = ret ? Py_True : Py_False;\n";
       pr "  Py_INCREF (py_ret);\n"
    | RConstString ->
       pr "  py_ret = PyUnicode_FromString (ret);\n"
    | RErr ->
       pr "  py_ret = Py_None;\n";
       pr "  Py_INCREF (py_ret);\n"
    | RFd
    | RInt ->
       pr "  py_ret = PyLong_FromLong (ret);\n"
    | RInt64 ->
       pr "  py_ret = PyLong_FromLongLong (ret);\n"
    | RString ->
       pr "  py_ret = PyUnicode_FromString (ret);\n";
       pr "  free (ret);\n"
  );

  pr "\n";
  pr " out:\n";
  List.iter (
    function
    | ArrayAndLen (UInt32 n, len) -> pr "  free (%s);\n" n
    | ArrayAndLen _ -> assert false
    | Bool _ -> ()
    | BytesIn (n, _) -> pr "  PyBuffer_Release (&%s);\n" n
    | BytesOut _ -> ()
    | Callback _ -> ()
    | Int _ -> ()
    | Int64 _ -> ()
    | Opaque _ -> ()
    | Path n -> pr "  free (%s);\n" n
    | SockAddrAndLen _ -> ()
    | String n -> ()
    | StringList n -> pr "  nbd_internal_py_free_string_list (%s);\n" n
    | UInt _ -> ()
    | UInt32 _ -> ()
    | UInt64 _ -> ()
  ) args;
  pr "  return py_ret;\n";
  pr "}\n";
  pr "\n"

let generate_python_methods_c () =
  generate_header CStyle;

  pr "#define PY_SSIZE_T_CLEAN 1\n";
  pr "#include <Python.h>\n";
  pr "\n";
  pr "#include <stdio.h>\n";
  pr "#include <stdlib.h>\n";
  pr "\n";
  pr "#include <libnbd.h>\n";
  pr "\n";
  pr "#include <methods.h>\n";
  pr "\n";
  List.iter (
    fun (name, fn) ->
      print_python_binding name fn "handle" "h"
  ) handle_calls;
  List.iter (
    fun (name, fn) ->
      print_python_binding name fn "connection" "conn"
  ) connection_calls

let generate_python_nbd_py () =
  generate_header HashStyle;

  pr "\
\"\"\"Python bindings for libnbd

import nbd
h = nbd.NBD ()
h.connect_tcp (\"localhost\", \"nbd\")
buf = h.pread (512, 0)

Read the libnbd(3) man page to find out how to use the API.
\"\"\"

import libnbdmod

AIO_DIRECTION_READ  = 1
AIO_DIRECTION_WRITE = 2
AIO_DIRECTION_BOTH  = 3

CMD_FLAG_FUA = 1<<0

class NBD (object):
    def __init__ (self):
        \"\"\"Create a new NBD handle\"\"\"
        self._o = libnbdmod.create ()

    def __del__ (self):
        \"\"\"Close the NBD handle and all connections\"\"\"
        libnbdmod.close (self._o)

    def get_connection (self, i):
        \"\"\"Get the i'th connection associated with the handle\"\"\"
        return NBDConnection (self, i)

";

  List.iter (
    fun (name, { args; shortdesc }) ->
      let args = List.map (
                     function
                     | ArrayAndLen (UInt32 n, _) -> n
                     | ArrayAndLen _ -> assert false
                     | Bool n -> n
                     | BytesIn (n, _) -> n
                     | BytesOut (_, count) -> count
                     | Callback (n, _) -> n
                     | Int n -> n
                     | Int64 n -> n
                     | Opaque n -> n
                     | Path n -> n
                     | SockAddrAndLen (n, _) -> n
                     | String n -> n
                     | StringList n -> n
                     | UInt n -> n
                     | UInt32 n -> n
                     | UInt64 n -> n
                   ) args in
      let args = List.map ((^) ", ") args in
      let args = String.concat "" args in
      pr "    def %s (self%s):\n" name args;
      pr "        \"\"\"%s\"\"\"\n" shortdesc;
      pr "        return libnbdmod.%s (self._o%s)\n" name args;
      pr "\n"
  ) handle_calls;

  pr "\
class NBDConnection (object):
    def __init__ (self, h, i):
        \"\"\"Get the i'th connection associated with the handle\"\"\"
        self._o = libnbdmod.get_connection (h, i)

    # Note there is intentionally no __del__ method.
    def close (self):
        \"\"\"Close this connection.  The i'th connection slot in
        the handle is reopened with a freshly created connection.

        The underlying C object is freed when you call this, so
        you must not call any other methods on the connection
        afterwards.
        \"\"\"
        libnbdmod.connection_close (self._o)
";

  List.iter (
    fun (name, { args; shortdesc }) ->
      let args = List.map (
                     function
                     | ArrayAndLen (UInt32 n, _) -> n
                     | ArrayAndLen _ -> assert false
                     | Bool n -> n
                     | BytesIn (n, _) -> n
                     | BytesOut (_, count) -> count
                     | Callback (n, _) -> n
                     | Int n -> n
                     | Int64 n -> n
                     | Opaque n -> n
                     | Path n -> n
                     | SockAddrAndLen (n, _) -> n
                     | String n -> n
                     | StringList n -> n
                     | UInt n -> n
                     | UInt32 n -> n
                     | UInt64 n -> n
                   ) args in
      let args = List.map ((^) ", ") args in
      let args = String.concat "" args in
      pr "    def %s (self%s):\n" name args;
      pr "        \"\"\"%s\"\"\"\n" shortdesc;
      pr "        return libnbdmod.%s (self._o%s)\n" name args;
      pr "\n"
  ) connection_calls;

  (* For nbdsh. *)
  pr "\
if __name__ == \"__main__\":
    import nbd
    import code
    import sys

    h = nbd.NBD ()
    sys.ps1 = \"nbd> \"

    banner = '''
Welcome to nbdsh, the shell for interacting with
Network Block Device (NBD) servers.

The ‘nbd’ module has already been imported and there
is an open NBD handle called ‘h’.

h.connect_tcp (\"remote\", \"10809\")   # Connect to a remote server.
h.get_size ()                       # Get size of the remote disk.
buf = h.pread (512, 0)              # Read the first sector.
exit() or Ctrl-D                    # Quit the shell
'''

    code.interact (banner = banner, local = locals(), exitmsg = '')
"

(*----------------------------------------------------------------------*)

(* Write the output files. *)
let () =
  output_to "lib/states.h" generate_lib_states_h;
  output_to "lib/states.c" generate_lib_states_c;
  output_to "lib/libnbd.syms" generate_lib_libnbd_syms;
  output_to "include/libnbd.h" generate_include_libnbd_h;
  output_to "lib/unlocked.h" generate_lib_unlocked_h;
  output_to "lib/api.c" generate_lib_api_c;
  output_to "docs/libnbd-api.pod" generate_docs_libnbd_api_pod;
  output_to "python/methods.h" generate_python_methods_h;
  output_to "python/libnbdmod.c" generate_python_libnbdmod_c;
  output_to "python/methods.c" generate_python_methods_c;
  output_to "python/nbd.py" generate_python_nbd_py
